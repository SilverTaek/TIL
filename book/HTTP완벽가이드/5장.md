## 웹 서버

- 웹 서버 소프트웨어 & 웹 페이지 제공에 특화 된 장비(컴퓨터)
- HTTP 및 그와 관련 된 TCP 처리를 구현
- 자신이 제공하는 리소스를 관리하고 웹 서버를 설정, 통제, 확장하기 위한 관리 기능을 제공
- TCP 커넥션 관리 책임을 나눔 - 웹서버, 운영체제

### 다목적 소프트웨어 웹 서버

- 네트워크에 연결된 표준 컴퓨터 시스템에서 동작한다.
- 아파치, W3C의 직소, Nginx…

### 임베디드 웹 서버

- 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버

### 간단한 펄 웹 서버

- type-o-server는 HTTP 커넥션을 기다린다.

### 웹 서버가 하는 일

1. 커넥션을 맺는다
2. 요청을 받는다
3. 요청을 처리한다
4. 리소스에 접근한다
5. 응답을 만든다
6. 응답을 보낸다
7. 트랜잭션을 로그로 남긴다

### 1단계: 클라이언트 커넥션 수락

- 클라이언트가 이미 서버에 대해 열려있는 지속적 커넥션을 갖고 있다면, 클라이언트는 요청을 보내기 위해 그 커넥션을 사용할 수 있다.
- 그렇지 않다면, 새 커넥션을 열 필요가 있다.

### 새 커넥션 다루기

- 클라이언트 → 웹 서버 ( TCP 커넥션 요청)
- 커넥션을 맺고, TCP 커넥션에서 IP 주소를 추출하고 커넥션 맞은편에 어떤 클라이언트가 있는지 확인
- 새 커넥션을 목록에 추가하고 준비를 한다. ( 단, 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다.)

### 클라이언트 호스트 명 식별

- 역방향(DNS)를 사용해서 클라이언트의 IP 주소를 클라이언트의 호스트 명으로 변환하도록 설정

### ident를 통해 클라이언트 사용자 알아내기

- 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 찾아낼 수 있게 해준다.
- 클라이언트는 ident 결과를 위해 TCP 포트 113번을 listen한다.
- 조직 내부에서는 잘 사용할 수 있지만, 공공 인터넷에서는 잘 동작하지 않는다.

### 2단계: 요청 메시지 수신

- 커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어 들이고 파싱하여 요청 메시지를 구상한다.
  - 요청줄을 파싱하여 요청 메서드, 지정된 리소스의 식별자, 버전 번호를 찾는다.
  - 메시지 헤더들을 읽는다.
  - 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다.
  - 요청 본문이 있다면, 읽어 들인다

### 메시지의 내부 표현

- 몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장한다.
- 자료 구조는 요청 메시지의 각 조각에 대한 포인터와 길이를 담을 수 있고, 헤더는 속도가 빠른 룩업 테이블에 저장되어 각 필드에 신속하게 접근할 수 있다.

### 커넥션 입력/출력 처리 아키텍처

- 고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원한다.

단일 스레드 웹 서버

멀티프로세스와 멀티스레드 웹 서버

다중 I/O 서버

다중 멀티스레드 웹 서버

### 3단계: 요청 처리

- 웹 서버가 요청을 받으면 서버는 요청으로부터 메서드, 리소스, 헤더, 본문을 얻어내러 처리한다.
- 다수의 메소드는 요청에 본문이 있는 것을 허용하되 요구하지는 않는다.

### 4단계: 리소스의 매핑과 접근

- 웹 서버는 리소스 서버다.

### Docroot

- 웹 서버는 여러 종류의 리소스 매핑을 지원한다.
- 일반적으로 웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약해두고 이 폴더가 문서 루트 혹은 `docroot`라고 불린다.
- 서버는 상대적인 url이 docroot를 벗어나서 파일 시스템의 docroot 이외 부분이 노출되는 일이 생기지 않도록 주의해야 한다.

### 디렉터리 목록

- 에러를 반환한다.
- 디렉터리 대신 특별한 ‘색인 파일’을 반환한다.
- 디렉터리를 탐색해서 그 내용을 담은 HTML 페이지를 반환한다.

### 동적 콘텐츠 리소스 매핑

- 웹 서버는 URI를 동적 리소스에 매핑

### 서버사이드 인클루드

- 어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어 있다면, 서버는 그 리소스의 콘텐츠를 클라이언트에게 보내기 전에 처리한다.

### 접근 제어

- 접근 제어되는 리소스에 대한 요청이 도착했을 때, 웹 서버는 클라이언트의 IP 주소에 근거하여 접근을 제어할 수 있고, 리소스에 접근하기 위한 비밀번호를 물어볼 수 도 있다.

### 5단계: 응답 만들기

- 한번 서버가 리소스를 식별하면, 서버는 요청 메서드로 서술되는 동작을 수행한 뒤 응답 메시지를 반환한다.

### 응답 엔터티

- MIME 타입을 서술하는 Content-Type 헤더
- Content-Length 헤더
- 실제 응답 본문의 내용

### 6단계: 응답 보내기

- 비지속적인 커넥션이라면, 서버는 모든 메시지를 전송했을 때, 자신쪽의 커넥션을 닫는다.

### 7단계: 로깅

- 트랜잭션이 완료되었을 때 웹 서버는 로그를 로그파일에 기록한다.

---

- 서버사이드 인클루드 - 코드 관리 편리하게 도와준다. ( 질문 )

Q. 왜 클라이언트의 IP 주소를 호스트 명으로 변환하도록 설정되어 있나요? (은택)

Q. 어떨 때, 호스트 명 분석을 꺼두거나 `특정` 콘텐츠에 대해서 꺼두나요? (은택)

Q. ident 프로토콜은 왜 TCP 포트 113번을 listen하나요? (은택)

Q. 웹 서비스는 어떤 기준으로 스레드/프로세스의 최대 개수에 제한을 거나요? 혹은 기본적으로 제한이 걸려있나요? (은택)

**이진**: 서버는 비지니스 처리와 디비 트랜잭션 처리로 이해를 했는데, 클라이언트에 전달하기전에 처리(서버사이드 인클루드)한다는 것을 알고나니 웹 서버에 대한 이해가 높아졌다.

TCP 113 번은 80, 8080 처럼 본인만의 서버 포트라는 생각이다.

반드시 호스트명을 알아야 할 필요는 없고, 필요할 경우에만 역 DNS 를 하면 된다.

로그는 키바나에서 보는 편

**찬용**: 커넥션 1개당 1개의 요청만 가능한가? → 이진: Yes / 부족하면 scale-out
