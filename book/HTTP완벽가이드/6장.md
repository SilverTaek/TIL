- 웹 중개자
  - 웹 중개자
    - 프록시는 서버이면서 동시에 클라이언트
    - 구현 시에 서버/클라이언트 양 쪽 규칙을 따라야함
    - 클라이언트와 웹 서버는 직접 통신하는 대신 프록시와 통신
  - 개인 프록시, 공유 프록시
    - 공유 프록시 : 여러 사용자의 공통된 요청에서 캐싱을 통해 이득을 취하도록함 (대부분의 프록시는 공유 프록시)
    - 개인 프록시 : 클라이언트에서 실행되어 브라우저의 기능 확장, 성능 개선, 광고 등을 위해 이용됨
  - 프록시 vs Gateway
    - 프록시는 같은 프로토콜을 사용하는 둘 이상을 연결하고, 게이트웨이는 다른 프로토콜을 사용하는 둘 이상은 연결함
    - 실질적으로 둘의 차이는 모호, 프록시가 서로 다른 버전의 HTTP(다른 프로토콜)을 중개하기도 하고
      방화벽/SSL/FTP 등을 중개하여 게이트웨이의 기능을 하고 있음
    - gateway 관련은 8장에서 이어서
- 프록시를 사용하는 이유
  - 보안 개선, 성능 향상, 비용 절약
  - 모든 HTTP 트래픽을 확인하여 중간에 제어 가능
    - 필터
    - 접근 제어
    - 보안 방화벽
    - 웹 캐시
    - 대리 프록시 (reverse proxy)
    - 컨텐츠 라우팅
    - 트랜스 코더 : 콘텐츠 본문 포맷을 수정 (무손실 압축, 리사이징, 언어 별로 맞춰 번역)
    - 익명 프록시 : 헤더에서 클라이언트를 특정할 수 있는 정보 등을 전부 제거해 줌
- 프록시 배치
  - 서버 배치
    - egress proxy : 트래픽 제어를 위해 로컬 네트워크 출구에 배치(필터)
    - ingress proxy : 다운로드 속드를 개선하고 인터넷 대역폭 비용을 줄이기 위해 배치
    - reverse proxy : 웹 서버의 앞에 위치하여 요청을 처리하고 필요한 요청만 서버로 보내기 위해 배치
    - 네트워크 교환 프록시 : 캐시를 사용해서 혼잡을 완화하고 트래픽 흐름을 감시하기 위해 교환 지점에 배치
  - 프록시 계층
    - 프록시를 연쇄적으로 구성할 수 있다.
    - 메시지가 원 서버에 최종 도착할 때까지 프록시와 프록시를 거쳐 이동
    - 정적 계층뿐만아니라 동적 계층도 가능
      - 부하균형, 지리, 프로토콜 타입, 유료 서비스 가입자 등
  - 프록시가 트래픽을 처리하는 방법
    - 클라이언트를 수정 (브라우저에서 설정)
    - 네트워크 수정 (인터셉트 프록시) : 네트워크가 인프라를 가로채서 프록시로 리다이렉트 하도록함(스위칭 장치, 라우팅 장치 필요)
    - Reverse Proxy : DNS 이름 공간을 수정
    - 서버를 수정 : 서버가 프록시로부터 클라이언트의 요청을 리다이렉트 하도록 설정할 수 있음
- 클라이언트 프록시 설정
  - 수동 설정
  - 브라우저의 기본 설정
  - Proxy Auto Configuration (PAC)
    - 자바스크립트 함수 파일로 능동적으로 프록시 서버를 지정할 수 있음
    - 일반적으로 .pac 확장자를 가지고, MIME TYPE ‘application/x-ns-proxy-autoconfig'를 가짐
    - 이 파일의 URI를 브라우저에게 알려줘야 하고, FindProxyForURL(url, host) 함수를 정의한 파일이어야함
    - WPAD (Web Proxy Auto Detection) 프로토콜 : 적당한 PAC 파일을 자동으로 찾아주는 알고리즘
- 프록시 요청의 미묘한 특징들
  - 프록시 요청 URI와 서버로의 URI 차이점
    - client → host
      - GET /index.html HTTP/1.0
    - client → proxy
      - GET http://www.http-study.com/index.html HTTP/1.0
    - 다른 이유
      - 원래의 HTTP 설계에선 proxy가 없었기 때문
        HTTP는 원래 클라이언트는 단일한 서버와 직접 통신을 했었기에 서버는 이미 호스트명과 포트 번호를 알고 있으므로 불필요한 전송을 피하려고 했음
      - 프록시가 생기면서 서버의 이름을 알 필요가 생김 → 프록시는 단일 서버만 사용하는게 아니라 여러 서버가 같은 물리적 웹 서버를 공유하기 때문
  - 가상 호스팅에서 일어나는 문제
    - 가상 호스팅에서는 full path가 있어야 함, 한 호스트가 여러 서비스를 호스팅 하기 때문임
      - 명시적인 프록시의 경우 프록시 자체가 full path를 요구함
      - 가상으로 호스팅되는 웹 서버는 생략된 host와 port를 포함하는 “Host”라는 헤더를 요구함
  - 인터셉트 프록시는 부분 URI를 받는다
    - 모든 클라이언트는 내가 프록시와 연결 되어있다는 사실을 몰라서 문제가 발생
    - 클라이언트는 웹 서버와 통신한다고 생각하여 생략된 부분 URI를 보냄
    - 다목적 프록시의 경우 프록시 요청과 서버 요청을 모두 다룰 수 있어야함
      - 완전한 URI 일 경우 그것을 사용
      - 생략된 URI일 경우 Host 헤더를 사용
      - 생략된 URI에 Host가 없는 경우
        - 대리 프록시라면 프록시에 실저 서버의 주소와 포트 번호가 설정되어 있음
        - 리버스 프록시라면 기존에 있었던 연결을 확인하여 판단 (20장)
        - 그 외에는 알아낼 수 있는 충분한 정보가 없으므로 에러를 내보냄
  - 전송 중 URI 변경
    - 몇몇 프록시는 다음 홉으로 보내기 전에 표준 형식으로 정규화하는 작업이 있다.
    - 프록시 서버는 요청 URI의 변경에 대해서 신경을 많이 써야함
    - 무해해 보이는 변형이라 할지라도, 상호운용성에 문제를 발생시킬 수 있음
    - 프록시 서버는 최대한 관대하도록 해야함
    - HTTP 명세에서는 절대 경로를 고쳐 쓰는 것을 금지함 (빈 경로를 ‘/’로 교체하는 것만 허용)
  - URI 클라이언트 자동 확장과 호스트 명 분석
    - 브라우저는 프록시 존재 여부에 따라 요청 URI를 다르게 분석함
    - 프록시가 없다면 사용자가 타이핑한 URI를 가지고 그에 대응하는 IP 주소를 찾음
    - 찾을 수 없는 경우 호스트 명의 확장을 제공(2장)
      - 접두사와 접미사를 붙임
      - 서드파티 사이트로 넘겨 오타 교정을 시도
      - 호스트 명의 앞 부분만을 입력해도 자동으로 도메인을 검색하도록 설정
  - 프록시가 없는 URI 분석
    - study를 사용자가 브라우저에 URI 창에 입력한 경우
    1. 접두사로 http:// 집어넣고 포트를 80으로 하고 기본 경로 ‘/’로 하여 검색
    2. 호스트 명을 자동으로 확장하여 DNS에서 주소 분해를 요청하여 www.study.com 으로 요청
  - 프록시를 통한 URI 분석
    - 명시적인 프록시
      - 명시적인 프록시를 사용하는 경우 호스트명을 자동으로 확장하지 않음 (URI가 프록시를 지나치기 때문)
    - 인터셉트 프록시
      - 클라이언트 입장에선 프록시가 존재하지 않는 것과 동일하지만 커넥션이 만들어지면 차이가 발생
      1. study 라고 URI에 타이핑
      2. DNS를 통해 찾아보지만 찾지 못하고 호스트는 알 수 없다고 응답
      3. 브라우저는 자동확장을 통해 www.study.com 으로 변환하여 DNS에 재요청하여 IP 주소를 얻음
      4. 클라이언트는 호스트 명을 분석하여 IP 주소의 목록을 가지고 있음
      5. 클라이언트는 성공할 때까지 모든 IP 주소에 대해서 접속을 시도함
      6. 인터셉트 프록시가 존재한다면 프록시 서버에 의해 접속 시도가 종료됨
      7. 프록시가 원 서버와 상호작용할 준비가 되었을 때, IP 주소가 실제로는 다운된 주소를 가리키고 있음을 알게 됨
      8. 프록시는 헤더 명을 분석하거나 역방향 DNS 룩업을 해서 다른 IP 주소로 재시도함 (장애 허용)
- 메시지 추적
  - 프록시를 많이 사용하면서 서로 다른 스위치, 라우터를 넘나들기 때문에 흐름을 추적하기 어렵다
  - Via 헤더
    - 메시지가 지나는 각 중간 노드의 정보를 나열
    - 프로토콜 변환도 기록
    - Via: 1.1 proxy-62.irenes-isp, 1.0 cache.jes-hardward.com
- 프록시 인증
  - 사용자가 유효한 접근 권한 자격을 프록시에 제출하지 않는 한 콘텐츠 요청 차단 ⇒ 407
- 프록시 상호 운용성

QnA

- 153p의 대리 프락시의 역할 (공용 콘텐츠에 대한 느린 웹 서버 성능 개선)은 CDN인가? 전 장의 웹캐시와 다른 점은?
- 다목적 프락시 서버가 완전 URI와 부분 URI를 모두 지원해야 하는 이유..?
- 그림 6-18 2a에서 호스트만 쳤을 때 DNS 서버가 성공하는 경우는 뭘까?

- 일반적인 프록시 (Forward 프록시)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf1c5f70-7933-4aec-8d50-a865e5dc4381/Untitled.png)

- 리버스 프록시

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fc491748-7119-41c5-b656-7f801e2036a6/Untitled.png)

참조

- [https://inpa.tistory.com/m/entry/NETWORK-📡-Reverse-Proxy-Forward-Proxy-정의-차이-정리](https://inpa.tistory.com/m/entry/NETWORK-%F0%9F%93%A1-Reverse-Proxy-Forward-Proxy-%EC%A0%95%EC%9D%98-%EC%B0%A8%EC%9D%B4-%EC%A0%95%EB%A6%AC)
