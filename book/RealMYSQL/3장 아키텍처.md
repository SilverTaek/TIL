# MySQL의 전체 구조

MySQL은 일반 상용 RDBMS에서 제공하는 대부분의 접근법을 모두 지원한다.
MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분해서 볼 수 있다.

## MySQL 엔진

클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 그리고 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다. 그리고 성능 향상을 위해 MyISAM의 키 캐시나 InnoDB의 버퍼 풀과 같은 보조 저장소 기능이 포함돼 있다.

## 스토리지 엔진

MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고, 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담한다.
MySQL 서버에서는 MySQL엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.

## 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에서 쓰기 또는 읽기를 요청하는 것
여기서 사용되는 API를 핸들러 API라고 한다.

## MySQL 스레딩 구조

### 포그라운드 스레드(클라이언트 스레드)

MySQL 서버에 접속한 사용자의 수만큼 존재하며 다시 돌아갈 때 스레드 캐시에 일정개수 이상 대기중이던 스레드 캐시에 넣지 않고 종료시킨다. 이렇게 스레드의 개수를 일정하게 유지하게 만들어주는 파라미터가 thread_cache_size이다.

### 백그라운드 스레드

- 인서트 버퍼를 병합하는 스레드
- 로그를 리스크로 기록하는 스레드
- InnoDB 버퍼 툴의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어들이는 스레드
- 기타 여러가지 잠금이나 데드락을 모니터링하는 스레드
- 모든 스레드를 총괄하는 메인 스레드

## 메모리 할당 및 사용 구조

MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.
글로벌 메모리 영억의 모든 메모리 공간은 MySQL 서버가 시작되면서 무조건 OS로부터 할당된다.

- 글로벌 메모리 영역

  - 클라이언트의 스레드 수와 무관하게 일반적으로 하나의 메모리 공간만 할당된다.
  - 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유된다.
  - 필요에 따라 2개이상 메모리 공간 할당이 가능하다.

- 로컬 메모리 영역
  - 세션 메모리 영역이라고도 한다. 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다. ex) 커넥션 버퍼, 정렬 버퍼
  - 각 클라이언트 별로 독립적으로 할당된다.

## 플러그인 스토리지 엔진 모델

마지막 "데이터 읽기/쓰기" 작업만 스토리지 엔진에 의해 처리된다.

- SQL 파서 <-> SQL 옵티마이저 <-> SQL 실행기 <-> 데이터 읽기/쓰기 <-> 디스크

  - SQL 파서부터 SQL 실행기까지는 MySQL 엔진의 처리를 담당한다.
  - 데이터의 읽기/쓰기는 스토리지 엔진이 담당한다.

Handler\_ : MySQL 엔진이 각 스토리지 엔진에게 보낸 명령의 횟수
GROUP BY / ORDER BY 등 쿼리 실행기에서 처리한다.

## 쿼리 실행 구조

파서 -> 전처리기 -> 옵티마이저

- 실행엔진은 핸들러에게 임시 테이블 요청 즉, 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청으로 연결하는 역할
- 파서 : 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업이다.
- 전처리기 : 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점을 확인한다.
- 옵티마이저 : DBMS의 두뇌로, 쿼리 문장을 어떻게 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 한다.
- 실행 엔진 : 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 한다.
- 핸들러(스토리지 엔진) : MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 한다.

## 복제

레플리케이션이라고도 하며 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술이다.

마스터(Master) : 바이너리 로그가 활성화되면 어떤 MySQL 서버든 마스터가 될 수 있다.
DML, DDL을 바이너리로그에 기록하고 Slave에 바이너리 덤프 스레드가 Slave로 넘겨준다.

슬레이브(Slave) : 릴레이 로그에 기록된 내용으로 변경 내역을 재실행한다.

## 복제 주의사항

- 슬레이브는 하나의 마스터만 실행 가능
- 슬레이브는 읽기 전용
- 마스터와 동일 사양
- 바이너리 로그 중지(복제가 필요없을 때)
- 바이너리 로그와 트랜잭션 격리 수준

## 쿼리 캐시

타 DBMS에는 없는 MySQL의 독특한 기능 중 하나로서 적절히 설정만 해두면 상당한 성능 향상 효과를 얻을 수 있다.

쿼리 캐시의 구조는 간단한 키와 값의 쌍으로 관리되는 맵(Map)과 같은 데이터 구조로 구현돼 있다. 여기서 키를 구성하는 요소 가운데 가장 중요한 것은 쿼리 문장 자체일 것이며, 값은 해당 쿼리의 실행 결과가 될 것이다.

## 쿼리 캐시의 확인 절차

- 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?
- 해당 사용자가 그 결과를 볼 수 있는 권한을 가지고 있는가?
- 트랜잭션 내에서 실행된 쿼리인 경우, 그 결과가 가시 범위 내의 트랜잭션에서 만들어진 결과인가?(InnoDB의 경우)
- 쿼리에 사용된 기능(내장 함수나 저장 함수 등)이 캐시돼도 동일한 결과를 보장할 수 있는가?
  - CURRENT_DATE, SYSDATE, RAND 등과 같이 호출 시점에 따라 결과가 달라지는 요소가 있는가?
  - 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가?
- 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
- 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?
- 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용됐는가?

## InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용할 수 있는 스토리 엔진 중에서 거의 유일하게 레코드 기반의 잠금을 제공하고 있으며, 때문에 높은 동시성 처리가 가능하고 또한 안정적이며 성능이 뛰어나다.

### InnoDB 스토리지 엔진의 특성

- 프라이머리 키에 의한 클러스터링
- 잠금이 필요 없는 일관된 읽기(Non-locking consistent read)
- 외래 키 지원
- 자동 데드락 감지
- 자동화된 장애 복구
- 오라클의 아키텍처 적용

## InnoDB 버퍼 풀

변경된 데이터를 모아서 처리하게 되면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

MyISAM 키 캐시가 인덱스의 캐시만을 주로 처리하는 데 비해 InnoDB 버퍼 풀은 디스크의 데이터 파일과 인덱스 정보 모두를 메모리에 캐시한다.
또한 `쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할`도 한다.
데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시키는데, 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

> 일반적으로 전체 물리 메모리의 50% ~ 80% 수준에서 버퍼 풀의 메모리 크기를 결정한다.

### 언두(Undo) 로그

UPDATE 나 DELETE 로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳이다.
크게 두 가지 용도로 사용되는데, 첫 번째는 트랜잭션의 롤백 대비용이고, 두 번째는 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하는 데 사용된다.

### 인서트 버퍼

INSERT, UPDATE 시에는 데이터 파일의 변경 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.
InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트하지만, 디스크로부터 결과를 가져와야 한다면 임시 공간에 저장해두고 사용자에게는 바로 결과를 반환하는 식으로 성능을 향상시킨다.
이 때 사용하는 임시 공간을 인서트 버퍼 라고 한다.

### 리두(Redo) 로그 및 로그 버퍼

변경된 데이터를 버퍼링하기 위한 버퍼 풀이 있어도 데이터의 ACID 를 보장하기는 어렵기 때문에, 변경된 내용을 순차적으로 기록하는 로그 파일인 리두 로그가 존재한다.
리두 로그는 사람의 눈으로 열어서 읽을 수 없기 때문에 굳이 열어볼 필요는 없다.

리두 로그 덕분에 DBMS 는 버퍼링을 통해 한꺼번에 디스크에 변경된 내용을 처리할 수 있게 되어 상당한 성능 향상을 얻었다.
다만 데이터 변경 작업이 많은 서버의 경우에는 리두 로그 기록 작업이 오히려 문제가 되는데, 이를 보완하기 위해 최대한 ACID 속성을 보장하는 수준에서 버퍼링하게 된다.
이 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼다.

```
ACID 는 데이터베이스에서 트랜잭션의 무결성을 보장하기 위해 반드시 필요한 4가지 요소를 의미한다.

A : Atomic. 트랜잭션은 원자성 작업 C : Consistent. 일관성 I : Isolated. 격리성 D : Durable. 한번 저장된 데이터는 지속적으로 유지돼야 한다.

일관성과 격리성은 서로 다른 두 개의 트랜잭션에서 동일 데이터를 조회하고 변경하는 경우에도 상호 간섭이 없어야 한다는 의미이다.
```

MVCC (Multi Version Concurrency Control)
MVCC 의 가장 큰 목적은 `잠금을 허용하지 않는 일관된 읽기` 를 제공하는 데 있다.
언두 로그를 이용해 이 기능을 구현한다.

예를 들어 특정 데이터 레코드를 1번 사용자가 'A' 내용에서 'B' 내용으로 UPDATE 한다고 가정해 보자.
이 때의 상황은 다음과 같다.

- InnoDB 버퍼 풀 : 수정된 'B' 내용이 반영되어 있다. (레코드 전체)
- Undo 로그 : 수정 전의 'A' 내용이 반영되어 있다. (PK, 메타정보 및 수정된 칼럼만 백업)

이 때 커밋이나 롤백이 아직 일어나지 않는 상황에서, 2번 사용자가 해당 데이터를 읽으려고 하면 어떻게 될까?

이 질문의 답은 격리 수준에 따라 다르다.

- READ_UNCOMMITTED : InnoDB 버퍼 풀이나 데이터 파일로부터 변경된 'B' 데이터를 읽어서 반환한다.
- READ_COMMITTED 이상 : 아직 커밋되지 않았기 때문에 언두 영역의 'A' 데이터를 반환한다.
  이러한 과정을 DBMS 에서는 MVCC 라고 표현한다.

## 잠금 없는 일관된 읽기

격리 수준이 SERIALIZABLE 이 아닌 그 이하의 격리 수준에서는 순수한 읽기 SELECT 작업은 다른 트랜잭션의 변경 작업과 관계 없이 잠금을 실행하지 않고 바로 실행된다.
특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 를 방해하지 않는다.
이를 잠금 없는 일관된 읽기 라고 표현하고, 변경되기 전의 데이터를 읽기 위해 InnoDB 에서는 언두 로그를 사용한다.
