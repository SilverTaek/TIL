# 인덱스
## 디스크 읽기 방식
디스크와 같은 기계식 장치의 성능의 발전은 제한적이라서 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건이다.
## 랜덤 I/O vs 순차 I/O
* 랜덤 I/O
디스크 드라이브의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽느 것을 의미한다.
* 순차 I/O
랜덤 I/O와 작업은 같지만 디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 랜덤 I/O에 비해 훨씬 적게 움직인다 따라서 속도가 약 3배 정도 빠르다.

## 인덱스란?
책의 제일 끝에 있는 찾아보기(색인)로 설명된다.
책의 내용은 데이터 파일, 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유된다.
레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들면 원하는 결과를 빠르게 찾을 수 있다.

## SortedList vs ArrayList

SortedList는 DBMS의 인덱스와 같은 자료구조이며, 저장된 값을 항상 정렬된 상태로 유지한다.
ArrayList는 데이터 파일과 같은 자료구조를 사용하며, 값을 저장되는 순서대로 그대로 유지하는 자료구조이다.

결과적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.

대표적으로 B-Tree, Hash 인덱스로 구분할 수 있으며 전문 검색, 공간 검색용 인덱스뿐만 아니라 최근에는 Fractal-Tree인덱스도 도입됐다.

## B-Tree 인덱스
인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘이다.

일반적으로 B+-Tree 또는 B*-Tree가 있다.

B-Tree는 트리 구조의 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태이다. 가장 하위에 있는 노드를 리프 노드라 하고, 중간 노드를 브랜치 노드라고 한다.
인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.

### B-Tree 인덱스 키 추가 및 삭제
새로운 키값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다.
저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. 하지만 리프 노드가 꽉 차서 더는 저장할 수 없으면 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어지게 되어 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려진다.

보통 테이블에 레코드를 추가하는 작업을 1이라 하면, 인덱스에 키를 추가하는 비용은 11.5 정도로 예측하는것이 일반적이다.

키 값이 삭제되는 경우는 상당히 간단한데 해당 키값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.

인덱스상의 키값만 변경하는 것은 불가능하다. B-Tree의 키값 변경 작업은 먼저 키값을 삭제한 후, 다시 새로운 키값을 추가하는 형태로 처리된다.

인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는것을 트리탐색이라고 한다.
트리탐색은 SELECT에서만 사용하는 것이 아니라 UPDATE, DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 인덱스가 있으면 빠른 검색이 가능하다.

## B-Tree 인덱스 사용에 영향을 미치는 요소
* 인덱스 키값의 크기
InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
InnoDB의 모든 페이지 크기는 16KB로 고정돼 있다. 하나의 페이지가 고정되어 있기 때문에, 인덱스의 키값이 커지면 한 인덱스에 저장할 수 있는 인덱스 키의 개수가 적어지고, 이는 같은 분량의 내용을 읽을 때 디스크로부터 읽어야 하는 횟수가 늘어나 그만큼 느려진다는 것을 의미한다.

* B-Tree 깊이
B-Tree 인덱스의 깊이는 상당히 중요하지만 직접적으로 제어할 방법은 없다. 결론적으로 인덱스 키값이 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키값의 개수가 작아지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미한다.

인덱스 키값의 크기는 가능하면 작게 만드는것이 좋다. 실제로는 아무리 대용량의 데이터베이스라도 B-Tree의 깊이가 4~5 이상까지 깊어지는 경우는 거의 발생하지 않는다.

* 선택도(기수성)
인덱스에서 선택도 또는 기수성은 거의 같은 의미로 사용되며, 모든인덱스 키값 가운데 유니크한 값의 수를 의미한다.
전체 인덱스 키값은 100개인데, 그중에서 유니크한 키값의 수는 10개라면 기수성은 10이다. 인덱스 키값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.

* 읽어야 하는 레코드의 건수
인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다. 인덱스를 통해 읽어야 할 레코드의 건수(옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 읽은 후 필터링 처리하는 것이 더 효율적이다.

## B-Tree 인덱스를 통한 데이터 읽기
* 인덱스 레인지 스캔
대표적인 접근 방식으로 아래 두 방법보다는 빠른 방법이다. 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.

루트 노드에서 시작해 브랜치 노드를 거쳐 최종적으로 리프 노드까지 찾아 들어가서 시작 지점을 찾은 후, 순방향 혹은 역방향으로 원하는 레코드의 끝 범위까지 스캔을 한다. 끝에 다다르면 지금까지 읽은 레코드들을 사용자에게 반환하고 쿼리를 끝낸다.

중요한 것은 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요한데, 이 과정에서 레코드 한 건 단위로 랜덤 I/O가 발생한다. 그렇기에 인덱스를 통해 데이터를 읽는 것이 바로 테이블을 읽는 것보다 비용이 많이 드는 것이다.

* 인덱스 풀 스캔
리프 노드를 처음부터 끝까지 읽는 방식을 인덱스 풀 스캔이라고 한다. 대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.

이는 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. 하지만 보통은 인덱스 풀 스캔 방식은 일반적으로 인덱스를 생성하는 목적에 부합하지 않기 때문에 인덱스를 사용하지 못한다고 표현한다.

* 루스 인덱스 스캔
말 그대로 듬성듬성 인덱스를 읽는 것을 의미한다. 일반적으로 GROUP BY 또는 MAX(), MIN() 함수를 사용해 최적화를 하는 경우에 사용한다. 옵티마이저가 WHERE 조건 등의 범위 전체를 다 스캔할 필요가 없음을 인지하면, 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다.

## 다중 칼럼 인덱스
두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스라고 한다.

가장 중요한 것은 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다는 것이다. 마찬가지로 n개의 컬럼으로 구성된 인덱스에서, i번째 칼럼은 항상 (i-1)번째 칼럼에 의존해서 정렬돼 있다. (i>=2)

따라서 2번째 칼럼은 1번째 칼럼이 같은 레코드에 대해서만 정렬되어 있고, 1번째 칼럼이 다른 경우에는 2번째 칼럼의 정렬 순서는 보장할 수 없다.

이 특성은 인덱스의 성능 및 적용점을 파악하는 데 아주 중요한 특성이므로 잘 알아두는 것이 좋다.

### B-Tree 인덱스의 가용성과 효율성
```
SELECT * FROM test_table
WHERE col_1 = 'c001' AND col_2 >= 12345;
```

이런 쿼리가 있다고 가정했을 때, 아래 각각 인덱스에 대해 어떤 일이 일어나는지 알아보자.

1. 인덱스 A : col_1 + col_2
2. 인덱스 B : col_2 + col_1

인덱스 A를 사용하는 경우, 먼저 "col_1 = 'c001' AND col_2 >= 12345"인 경우를 찾고, 그 이후로는 col_1이 'c001'이 아닐 때까지 인덱스를 쭉 읽기만 하면 된다.

하지만 인덱스 B를 사용하는 경우, 정렬 조건을 고려해 보면 먼저 "col_1 = 'c001' AND col_2 >= 12345"인 경우를 찾고, 그 이후로는 모든 레코드에 대해 col_1이 'c001'인지 판별하는 과정을 가져야만 한다. 결국 인덱스 B에서 col_2는 비교 작업의 범위를 좁히는 데에 아무런 도움을 주지 못했다.

인덱스 A의 경우에서처럼 작업의 범위를 결정하는 조건을 작업 범위 결정 조건이라 하고, 인덱스 B의 col_2처럼 단순히 거름종이 역할만을 하는 조건을 필터링 조건 혹은 체크 조건이라고 표현한다.

작업 범위를 결정하는 조건은 많으면 많을수록 좋다. 반대로 체크 조건은 오히려 쿼리 실행을 더 느리게 만들 수도 있다. 인덱스를 적절하게 사용하기 위해서는 쿼리의 조건을 작업 범위 결정 조건에 알맞게 작성하던지, 아니면 쿼리에 맞게 인덱스를 생성하는 것이 좋은 방법이다.

## 가용성과 효율성 판단
작업 범위 결정 조건으로 사용할 수 없는 조건을 잘 알아두는 것이 중요하다.

* NOT-EQUAL로 비교된 경우 ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")

* LIKE '%??' (앞부분 비교가 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우

* 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우 (ex. SUBSTRING, DAYOFMONTH)

* NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우

* 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)

* 문자열 데이터 타입의 콜레이션이 다른 경우(UTF8, EUCKR)

그리고 MySQL에서는 다른 DBMS와 달리 NULL 값도 인덱스로 관리되기 때문에 IS NULL 조건도 작업 범위 결정 조건으로 활용될 수 있다.

다중 칼럼 인덱스의 경우는 다음과 같이 나뉜다.

INDEX idx_test ( col_1, col_2, ... , col_n)

1. 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
* col_1 칼럼에 대한 조건이 없거나, col_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
2. 작업 범위 결정 조건으로 인덱스를 사용하는 경우 (i >= 2)
* col_1 ~ col_(i-1)까지 EQUAL 형태("=" 또는 "IN")로 비교
* col_i 칼럼에 대해 EQUAL 형태("=" 또는 "IN"), 크다 작다 형태(">" 또는 "<"), LIKE로 좌측 일치 패턴(LIKE 'ab%') 중 하나로 비교

# 해시(Hash) 인덱스
## 해시 인덱스의 구조와 특성
해시 인덱스는 동등 비교 검색에는 최적화돼 있지만 범위 검색이나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다.

이름에서 알 수 있듯이 해시 함수를 사용해 인덱스를 구성하는데, 보통은 메모리 기반의 테이블에 주로 구현돼 있고 디스크 기반의 대용량 테이블로는 거의 사용되지 않는다.

해시 인덱스의 큰 장점은 실제 키값과는 관계없이 해시 함수의 결과를 이용하기 때문에 인덱스 크기가 작고 검색이 빠르다는 것이다. 트리 형태의 구조가 아니라서 검색하고자 하는 값을 주면 해시 함수를 거쳐서 원하는 키값이 포함된 버켓을 알아낼 수 있다. 그리고 해당 버켓만 읽어 빠르게 실제 레코드 저장 위치를 알 수 있다.

## 해시 인덱스의 가용성 및 효율성
동등 비교 조건으로 값을 검색하면 해시 인덱스를 사용할 수 있다. 예를 들면 "=", "<=>", "IN", "IS NULL", "IS NOT NULL"과 같은 것들이 있다. IN 연산자도 결국 여러 개의 동등 비교로 풀어서 처리할 수 있기 때문에 같은 효과를 얻을 수 있다. ("<=>"은 NULL-Safe EQUAL 연산자로 양쪽이 모두 NULL인 경우를 제외하고는 "="과 똑같이 작동하는 연산자이다.)

반대로 ">", "<", "BETWEEN ~ AND", "LIKE", "<>" 등의 크다 작다 기반의 검색은 해시 인덱스를 사용할 수 없다. 다중 칼럼 인덱스에서도 모든 칼럼이 동등 비교 조건으로 비교되는 경우에만 해시 인덱스를 사용할 수 있다.

## 클러스터링 인덱스
클러스터란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 인덱스의 클러스터링도 그 의미를 크게 벗어나지 않는다.

클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용디며 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다. 프라이머리 키값에 의해 레코드의 저장 위치가 결정된다는 것이다.

## 클러스터 테이블 사용 시 주의사항
* 클러스터 인덱스 키의 크기
* 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생산할것(가능한 경우)
* 프라이머리 키는 반드시 명시할 것
* AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

## 유니크 인덱스
유니크란 사실 인덱스라기보다는 제약 조건에 가깝다고 볼 수 있다. 말 그대로 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미한다.

### 유니크 인덱스와 일반 보조 인덱스의 비교
* 인덱스 읽기
* 인덱스 쓰기
### 유니크 인덱스 사용 시 주의사항
성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지는 않는 편이 좋다.

## 외래키
MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다. 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.
