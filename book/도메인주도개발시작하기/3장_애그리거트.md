## 3.1 애그리거트

- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요하다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5baca86c-44f6-4c5e-81f4-eeac157864cf/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e7274d9b-5a48-4cfb-b92e-9cdfcfce8333/Untitled.png)

예시

- Product와 Review는 함께 생성되지 않고, 함께 변경되지도 않는다.

처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만 도메인에 대한

경험이 생기고 도메인 규칙을 제대로 이해할수록 실제 애그리거트의 크기는 줄어들게 된다.

## 3.2 애그리거트 루트

- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안된다.
- 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할주체가 필요한데 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다.

### 3.2.1 도메인 규칙과 일관성

- 주문 애그리거트는 배송지 변경, 상품 변경과 같은 기능을 제공하고, 애그리거트 루트인 Order가 이 기능을 구현한 메서드를 제공한다.
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다.

```jsx
단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
밸류 타입은 불변으로 구현한다.
```

### 3.2.2 애그리거트 루트의 기능 구현

- 애그리거트 루트가 구성요소의 상태만 참조하는것은 아니다. 기능 실행을 위임하기도 한다.
- protected 범위로 한정해서 외부에서 실행할 수 없도록 제한하는 방법도 있다.

### 3.2.3 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋다.
- 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아지기 때문에 한번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어지게 된다.

```jsx
만약 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면
응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다

=> 하나로 묶어서 트랜잭션 처리를 하라는 말인가?
```

### 3.3 리포지터리와 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재해야 한다.
- 애그리거트를 구하는 리포지터리 메서드는 완전한 에그리거트를 제공해야하며 아닌 경우 NPE 문제가 발생할 수 있다.
- 애그리거트 상태가 변경되면 원자적으로 저장소에 반영해야 한다.

### 3.4 ID를 활용한 애그리거트 참조

- 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.
- 두 번째 문제는 애그리거트를 직접 참조하면 성능과 관련된 여러 가지 고민을 해야 한다. JPA 를 사용할 경우 참조한 객체를 지연로딩(Lazy)과 즉시로딩(Eager)의 두 가지 방식으로 로딩할 수 있다.
- 도메인별로 시스템을 분리하면 더 이상 다른 애그리거트 루트를 참조하기 위해 JPA 와 같은 단일 기술을 사용할 수 없다.

3가지 문제를 해결하기 위해 ID를 이용해서 다른 애그리거트를 참조한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98027627-0485-4b5c-898d-63cf0e51d38d/Untitled.png)

### 3.4.1 ID를 이용한 참조와 조회 성능

- 한 DBMS 에 있다면 조인을 이용해 한번에 가져올 수 있음에도 불구하고주문마다 상품 정보를 읽어오는 쿼리를 실행하게 된다.
- ID를 이용한 애그리거트 참조는 지연로딩과 같이 N+1 조회 문제가 발생한다.이는 조회 전용 쿼리 + Projection 을 사용하여 해결하면된다.
- 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성할 수 도 있다.

### 3.5 애그리거트 간 집합 연관

### 3.6 애그리거트를 팩토리로 사용하기

- 중요한 도메인 로직 처리가 응용 서비스에 노출이 될 경우, 기능을 분리해서 애그리거트에 옮길 수 있다. 이 경우 해당 애그리거트의 메서드가 팩토리 역할을 할 수 있다.
- 결론적으로 도메인의 응집도도 높아지고, 애그리거트를 팩토리로 사용할 때, 얻을 수 있는 장점이다.

애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트 팩토리 메서드를 구현하는 것을 고려하자!
