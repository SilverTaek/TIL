# HTTP 프로토콜
HTTP(Hypertext Transfer Protocol)는 인터넷상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜이다.
애플리케이션 레빌의 프로토콜로 TCP/IP 위에서 작동한다.
HTTP는 어떤 종류의 데이터든지 전송할 수 있도록 설계돼 있다. 
HTTP로 보낼 수 있는 데이터는 HTML문서, 이미지, 동영상, 오디오, 텍스트 문서 등 여러종류가 있다.
하이퍼텍스트 기반으로(Hypertext) 데이터를 전송하겠다(Transfer) = 링크기반으로 데이터에 접속하겠다는 의미이다.

![image](https://user-images.githubusercontent.com/43171179/124402817-9079b080-dd6d-11eb-964c-366cf1fa4411.png)

## 클라이언트 

서버에 요청하는 클라이언트 소프트웨어(IE, Chrome, Firefox, Safari ...)가 설치된 컴퓨터를 이용한다. 

클라이언트는 URI를 이용해서 서버에 접속하고, 데이터를 요청할 수 있다.


## 서버 

클라이언트의 요청을 받아서, 요청을 해석하고 응답을 하는 소프트웨어가 설치된 컴퓨터(Apache, nginx, IIS, lighttpd) 등이 서버 소프트웨어다.

웹서버는 보통 표준포트인 80번 포트로 서비스한다.

## Connectionless & Stateless

HTTP는 Connectionless 방식으로 작동한다.
서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버린다.
기본적으로는 자원 하나에 대해서 하나의 연결을 만든다.

### 장점
불특정 다수를 대상으로 하는 서비스에 적합한 방식이다. 

수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리할 수 있다.

### 단점
연결을 끊어버리기 때문에, 클라이언트의 이전 상태를 알 수가 없다. 

이러한 HTTP의 특징을 stateless라고 하는데, Connectionless 로 부터 파생되는 특징이라고 할 수 있다. 

클라이언트의 이전 상태 정보를 알 수 없게 되면, 웹 서비스를 하는데 당장에 문제가 생긴다. 

클라이언트가 과거에 로그인을 성공하더라도 로그 정보를 유지할 수가 없다. HTTP는 cookie를 이용해서 이 문제를 해결하고 있다.

 

Cookie는 클라이언트와 서버의 상태 정보를 담고 있는 정보조각이다. 

로그인을 예로 들자면, 클라이언트가 로그인에 성공하면, 

서버는 로그인 정보를 자신의 데이터베이스에 저장하고 동일한 값을 cookie형태로 클라이언트에 보낸다. 

 

첫 요청 시 :

클라이언트 로그인 성공 then 서버 로그인정보를 자신의 DB에 저장 

(서버는 cookie를 키로하는 값을 데이터베이스에 저장하는 방식으로 "세션"을 유지한다)

and then return 쿠키 to 클라이언트 

 

클라이언트는 다음 번 요청때 cookie를 서버에 보내는데, 

서버는 cookie 값으로 자신의 데이터베이스를 조회해서 로그인 여부를 확인할 수 있다. 

 

두번쨰 요청 시 :

클라이언트 request(cookie) to server then 서버는 자신의 DB 조회 and then 로그인여부 확인

## URI(Uniform Resource Identifiers)

클라이언트 소프트웨어(IE, Chrome, Firefox, Safari ...)는 URI를 이용하여 자원의 위치를 찾는다. 

 

URI는 HTTP와는 독립된 다른 체계다. 

HTTP는 전송 프로토콜이고, URI는 자원의 위치를 알려주기 위한 프로토콜이다. 

 

Uniform Resource Identifiers 의 줄임로, World Wide Web 상에서 접근하고자 하는 자원의 위치를 나타내기 위해서 사용한다. 

자원은 HTML문서, 이미지, 동영상, 오디오, 텍스트 문서 등 모든 것이 될 수 있다.

```
https://www.ssafy.com/index.html 를 분해하여 분석해보자.

 

https : 자원에 접근하기 위해서 https 프로토콜을 사용한다.

 

www.ssafy.com : 자원의 인터넷 상에서의 위치는 www.ssafy.com이다. 

도메인은 ip 주소로 변환되므로, ip 주소로 서버의 위치를 찾을 수 있다.

 

index.html : 요청할 자원의 이름이다.
```

## Method(메서드)

메서드는 요청의 종류를 서버에게 알려주기 위해서 사용한다. 

다음은 요청에 사용할 수 있는 메서드들이다.


GET : 정보를 요청하기 위해서 사용한다. (SELECT)

POST : 정보를 밀어넣기 위해서 사용한다. (INSERT)

PUT : 정보를 업데이트하기 위해서 사용한다. (UPDATE)

DELETE : 정보를 삭제하기 위해서 사용한다. (DELETE)

HEAD : (HTTP)헤더 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.

OPTIONS : 웹서버가 지원하는 메서드의 종류를 요청한다.

TRACE : 클라이언트의 요청을 그대로 반환한다. 예컨데 echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용한다.

각 용도에 맞는 메서드가 준비돼 있음에도 GET과 POST만으로도 모든 종류의 요청을 표현할 수 있다.

명시적으로 메서드를 사용하지 않아도 웹 서비스 개발에 큰 문제는 없지만

Restful API 서버의 경우에는 GET, POST, DELETE, PUT을 명시적으로 구분한다. 

자원의 위치 뿐만 아니라 자원에 할 일 까지 명확히 명시할 수 있기 때문에, 

Open API 서버를 만들기 위해서 널리 사용한다.

## 요청데이터 포맷

 

1. 요청 메서드 : GET, PUT, POST, PUSH, OPTIONS 등의 요청 방식이 온다. ( GET )

2. 요청 URI : 요청하는 자원의 위치를 명시한다. ( URI )

 

3. HTTP 프로토콜 버전 : 웹 브라우저가 사용하는 프로토콜 버전이다.( HTTP/1.1 )

 

## 응답헤더 포맷

 

프로토콜과 응답코드 : ( HTTP/1.1 200 OK )

날짜 : ( Date: Sun, 12 Aug 2018 11:30:00 GMT )

서버 프로그램및 스크립트 정보 : ( Apache/2.2.4 (Unix) PHP/5.2.0 ) 

응답헤더에는 다양한 정보를 추가할 수가 있다. 

컨텐츠의 마지막 수정일

캐쉬 제어 방식.

컨텐츠 길이.

Keep Alive기능 설정

## 응답코드

2xx - 성공
200번대의 상태 코드는 대부분 성공을 의미합니다.

200 : GET 요청에 대한 성공
204 : No Content. 성공했으나 응답 본문에 데이터가 없음
205 : Reset Content. 성공했으나 클라이언트의 화면을 새로 고침하도록 권고
206 : Partial Conent. 성공했으나 일부 범위의 데이터만 반환
3xx - 리다이렉션
300번대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우입니다.

301 : Moved Permanently, 요청한 자원이 새 URL에 존재
303 : See Other, 요청한 자원이 임시 주소에 존재
304 : Not Modified, 요청한 자원이 변경되지 않았으므로 클라이언트에서 캐싱된 자원을 사용하도록 권고. ETag와 같은 정보를 활용하여 변경 여부를 확인
4xx - 클라이언트 에러
400번대 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우입니다. 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생합니다. 가장 익숙한 상태 코드는 404 코드입니다. 요청한 자원이 서버에 없다는 의미죠.

400 : Bad Request, 잘못된 요청
401 : Unauthorized, 권한 없이 요청. Authorization 헤더가 잘못된 경우
403 : Forbidden, 서버에서 해당 자원에 대해 접근 금지
405 : Method Not Allowed, 허용되지 않은 요청 메서드
409 : Conflict, 최신 자원이 아닌데 업데이트하는 경우. ex) 파일 업로드 시 버전 충돌
5xx - 서버 에러
500번대 상태 코드는 서버 쪽에서 오류가 난 경우입니다.

501 : Not Implemented, 요청한 동작에 대해 서버가 수행할 수 없는 경우
503 : Service Unavailable, 서버가 과부하 또는 유지 보수로 내려간 경우

# HTTPS
HTTP 에 암호화와 인증, 그리고 완전성 보호를 더한 HTTPS

HTTPS는 SSL 의 껍질을 덮어쓴 HTTP 라고 할 수 있다. 즉, HTTPS 는 새로운 애플리케이션 계층의 프로토콜이 아니라는 것이다. HTTP 통신하는 소켓 부분을 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 프로토콜로 대체하는 것 뿐이다. HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 SSL 과 통신하고 SSL 이 TCP 와 통신 하게 된다. SSL 을 사용한 HTTPS 는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.

HTTPS 의 SSL 에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다. 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다.

모든 웹 페이지에서 HTTPS를 사용해도 될까?
평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구한다. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어들게 된다.

하지만 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작한다. 따라서 웹은 과거의 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용하는 방식에서 현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있다.