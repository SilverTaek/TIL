## Q. 공개 키 암호화와 비밀 키 암호화에 대해 설명해주세요.
공개 키 암호화는 두개의 다른 키를 사용한다. 공개키와 개인키이며 공개키는 모든 사람이 접근 가능한 키, 개인키는 각 사용자 자신만이 소유하는 키이다.

공개 키 암호의 대표적인 예는 공인인증서가 있다.

비밀 키 암호화는 한개의 키를 사용하며 비밀리에 보관한다. 키를 교환하는 것이 어려우며 위험하다. 하지만 공개키에 비해 암호화 속도가 빠르다는 장점이 있다.

## Q. 캡슐화에 대해 설명해주세요.

캡슐화는 객체 지향 프로그래밍에서 다음 2가지 측면이 있다.

객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고,
실제 구현 내용 일부를 외부에 감추어 은닉한다.

개인적으로는 데이터와, 데이터를 처리하는 행위를 묶고, 외부에는 그 행위를 보여주지 않는 것으로 정의 할 수 있다.

캡슐화를 통해 우리가 얻을 수 있는 이점중 가장 큰것은 코드의 중복을 피할 수 있다는 점과, 데이터를 처리하는 동작 방식을 외부에서 알 필요가 없다는 점이다.

## Q. 캐시란 뭐고, 어떤 목적으로 쓰는 건가요?

Cache는 데이터나 값을 미리 복사해 놓는 임시 저장소이다.

원본 데이터에 접근하는 시간이 오래 걸리는 경우, 값을 다시 계산하는 시간을 절약하고 싶은 경우 사용한다.

즉, 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.

`웹 서비스 캐시 똑똑하게 다루기` 라는 주제로 HTTP 캐시 관련 내용이 좋아서 공유합니다.

https://toss.tech/article/smart-web-service-cache

## Q. List 와 Set 의 차이에 대해 설명해주세요.
Java에서의 List와 Set 의 차이에 대해 설명하겠습니다.

1) 가장 큰 차이점은 순서입니다. List는 순서가 있는 Collection이며 List에 데이터를 넣는 순서가 보장됩니다. 그렇기 때문에 index로 특정 아이템을 가져올 수 있습니다.

Set은 순서를 보장하지 않는 Colletction입니다. 그렇기 때문에 index로 특정 아이템을 가져올 수 없습니다.

2) List는 중복을 허용합니다. 즉, 중복된 아이템을 List에 추가할 수 있습니다. 

반면에 Set은 중복을 허용하지 않습니다. 즉, 중복된 아이템은 Set에 추가되지 않습니다.

결론) 저장되는 데이터의 순서를 보장해야한다면 List를 사용해야 합니다. `contains(element)`는 Collection에 데이터가 존재하는지 확인하는 메서드입니다. List의 contains 실행속도는 O(n)이지만, Set는 O(1)으로 매우 빠릅니다. 탐색이 잦다면 Set를 고려해볼 수 있습니다.

데이터가 많지 않다면 성능보다, 구조가 간단한 List를 고려해볼 수 있습니다.

중복을 허용하지 않는 Collection이 필요하다면 Set을 고려해볼 수 있습니다.

## Q. 이진 탐색의 최선 / 최악의 경우에 대해 말씀해주세요.

## Q. 손실 압축과 무손실 압축의 차이에 대해 설명해주세요.

## Q. RSA 로 공개 키를 만들 때, 키 길이를 정하는 기준이 있습니까? 키 길이를 길게 하면 암호화 문제를 완벽 해결할 수 있나요?

## Q. 순환 Queue 를 만드려면 어떻게 하시겠습니까? 그리고 어떤 Queue 또는 Graph 가 무한 순환 구조라는 것을 어떻게 판단하시겠습니까?

## Q. 압축 알고리즘을 설계하라는 요구사항이 들어왔다면, 어떻게 구현하시겠습니까?

## Q. 전화번호부 앱을 만든다고 가정하겠습니다. 1명당 1KiB의 정보를 갖도록 모델을 설계했습니다. 앱이 온전히 사용할 수 있는 메모리가 4메가인 기기에서, 10000명(총 10메가)의 이용자 정보를 검색할 수 있도록 구현해야 합니다. 어떻게 하시겠습니까?

## Q. (JVM 경험자 한정) 배열과 ArrayList, LinkedList 의 차이점은 무엇인가요?

JCF 계층 구조를 보면 `LinkedList`는 `ArrayList`와는 달리 List 인터페이스를 구현한 `AbstractLis`t를 상속하지 않고 ``AbstractSequentialList를 상속하고 있습니다.

`ArrayList`는 데이터들이 순서대로 쭉 늘어선 배열의 형식을 취하고 있는 반면 `LinkedList`는 순서대로 늘어선 것이 아니라 자료의 주소 값으로 서로 연결되어 있는 구조를 하고 있습니다.

`LinkedList`는 `ArrayList`와 비교하여 여러가지 장점을 지니고 있습니다. `LinkedList`는 몇개의 참조자만 바꿈으로써 새로운 자료의 삽입이나 기존 자료의 삭제를 위치에 관계없이 빠른 시간안에 수행 할 수 있습니다. `ArrayList` 같은 경우는 O(N)만큼의 연산 속도가 걸리기 때문에 자료의 최대 개수에 영향을 받지만, `LinkedList`는 그런 제약을 받지 않습니다. 또한 `LinkedList`는 무한 개수의 자료를 삽입할 수 있는 반면, `ArrayList`는 크기가 한정되어 있기 때문에 결국 포화 상태에 이르게 됩니다. `ArrayList`의 크기를 재조정하는 연산을 수행하여 크기를 늘릴 수 도 있지만, 상당한 연산량이 요구됩니다.