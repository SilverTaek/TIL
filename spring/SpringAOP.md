# Spring AOP란?
Spring AOP는 AspectJ라는 구현체를 통해서 사용할 수도 있고 Spring 자체적으로 AOP를 구성하여 사용할 수도있다.

이러한 기능들로 Spring에서는 트랜잭션이나 캐쉬기능을 제공하고 있다.

**AOP는 흩어진 관심사(Cross-cutting Concerns)를 모아서 Aspect를 모듈화 할 수 있는 프로그래밍 기법이다.**
> * 핵심 기능(Core Concerns) : 업무 로직을 포함하는 기능
* 부가 기능(Cross-cutting Concerns) : 핵심 기능을 도와주는 부가적인 기능(로깅,보안)

AOP에대해서 좀더 자세히 살펴보면 애플리케이션에서의 관심사의 분리(기능의 분리), 핵심적인 기능에서 부가적인 기능을 분리한다. 분리한 부가기능을 Aspect라는 모듈형태로 만들어서 설계하고 개발하는 방법이다.

OOP를 적용하여도 핵심기능에서 부가기능을 쉽게 분리된 모듈로 작성하기 어려운데 이러한 문제점을 AOP가 대신 해결해준다.

최종적으로 객체지향적인 가치를 지킬수 있도록 도와주는 개념이라고 볼 수 있다.


### AOP 주요 용어
* Aspect : 부가기능을 정의한 코드인 어드바이스(Advice)와 어드바이스를 어디에 적용할지를 결정하는 포인트컷(PointCut)을 합친 개념
싱글톤 형태의 객체로 존재
* Advice : 해야할 일들(부가기능)을 정의
* pointcut : Advice를 어디에 적용해야하는지에 대한 정보를 들고 있다.
* target : 적용이 될 대상
* Join point : Advice가 적용될 수 있는 위치, 타겟 객체가 구현한 인터페이스의 모든 메서드는 조인 포인트가 된다. 
메소드 실행 시점 실행할때 advice를 끼워넣어라 그 시점을 join point라고함 
ex) 생성자를 호출할때, 필드에 접근하기전 등등
* Advisor : Advice + PointCut
Spring AOP에서만 사용되는 특별한 용어
* Weaving : 포인트컷에 의해서 결정된 타겟의 조인 포인트에 부가기능(어드바이스)를 삽입하는 과정을 뜻한다. AOP가 핵심기능(타켓)의 코드에 영향을 주지 않으면서 필요한 부가기능(어드바이스)를 추가할 수 있도록 해주는 핵심적인 처리과정 



### AOP 구현체
* Java 
AspectJ : 많은 다양한 기능을 제공
스프링 AOP : 국한적으로 기능을 제공

### Spring AOP 특징

1. Spring은 프록시 기반 AOP를 지원한다.

- Spring은 타겟(target) 객체에 대한 프록시를 만들어 제공한다.

- 타겟을 감싸는 프록시는 실행시간(Runtime)에 생성된다.

- 프록시는 어드바이스를 타겟 객체에 적용하면서 생성되는 객체이다.

2. 프록시(Proxy)가 호출을 가로챈다(Intercept)

- 프록시는 타겟 객체에 대한 호출을 가로챈 다음 어드바이스의 부가기능 로직을 수행하고 난 후에 타겟의

핵심기능 로직을 호출한다.(전처리 어드바이스)

- 또는 타겟의 핵심기능 로직 메서드를 호출한 후에 부가기능(어드바이스)을 수행하는 경우도 있다.(후처리 어드바이스)


3. Spring AOP는 메서드 조인 포인트만 지원한다.

- Spring은 동적 프록시를 기반으로 AOP를 구현하므로 메서드 조인 포인트만 지원한다.

- 핵심기능(타겟)의 메서드가 호출되는 런타임 시점에만 부가기능(어드바이스)을 적용할 수 있다.

- 반면에 AspectJ 같은 고급 AOP 프레임워크를 사용하면 객체의 생성, 필드값의 조회와 조작,

static 메서드 호출 및 초기화 등의 다양한 작업에 부가기능을 적용 할 수 있다.

### AOP 적용 방법
* 컴파일(aspectJ) : 성능적인 부하가 없다. 하지만 별도의 컴파일링을 한번 더해야한다는 단점이 있다.
* 로드 타임 : 위빙 즉 끼워서 넣는것 A라는 클래스를 로딩할때 끼워서 넣는다. 클래스 로딩할때 약간의 부하가 발생하며 로더타임 위버를 설정해줘야한다.
aspectj를 사용할 수 있어 다양한 문법을 사용가능하다는 장점이 있다.
* 런타임(aspectJ) : spring aop가 사용하는 방법이며 A라는 빈에 스프링이 미리 알고있다 A라는 빈을 만들때 (런타임) A라는 타입에 프록시 빈을 만든다 -> A가 가진 foo라는 메소드를 실행하기 직전에 hello를 하고 실행
단점은 초기 빈을 만드는 성능이 추가된다는점 하지만 실제 애플리케이션 요청이 들어올때마다 성능을 잡아먹는건 아니기때문에 최초 빈을 만들때만 부가적인 비용이 들어가기때문에 로드타임 위빙이랑 비용이 비슷하다고 생각합니다.
아무런 설정을 하지않아도 되고 문법이 쉽고 별도의 AOP공부를 많이 할필요도없다는게 장점입니다.


런타임에 프록시를 만들 수 있는데 spring AOP의 방법을 혼합해서 프록시패턴을 만들때 중복되는 코드 지저분한 코드들을 깔끔하게 해결할 수 있다.

참고 클래스 : AbstractAutoProxyCreator

### Advice 종류
> @Around
메소드 호출을 감싸고 있어서 어디에 적용하겠다.
execution 어디에 적용할지를 정의
타겟의 메서드가 호출되기 이전(before) 시점과 이후(after) 시점에 모두 처리해야 할 필요가 있는 부가기능을 정의한다. => JoinPoint 앞과 뒤에서 실행되는 Advice

> @Before
타겟의 메서드가 실행되기 이전(before) 시점에 처리해야 할 필요가 있는 부가기능을 정의한다.
=> JoinPoint 앞에서 실행되는 Advice

> After Returning
타겟의 메서드가 정상적으로 실행된 이후(after) 시점에 처리해야 할 필요가 있는 부가기능을 정의한다. => JoinPoing 메서드 호출이 정상적으로 종료된 뒤에 실행되는 Advice

>After Throwing
타겟의 메서드가 예외를 발생된 이후(after) 시점에 처리해 할 필요가 있는 부가기능을 정의한다. => 예외가 던져 질때 실행되는 Advice

참고 문헌
https://shlee0882.tistory.com/206
https://www.inflearn.com/course/spring-framework_core/dashboard
