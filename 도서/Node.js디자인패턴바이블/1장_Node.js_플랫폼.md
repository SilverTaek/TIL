## 1-1 Node.js 철학

### 1-1-1 경량 코어
* 최소한의 기능 세트를 가지고 코어의 바깥부분에 유저랜드 혹은 유저스페이스라 불리는 사용자 전용 모듈 생태계를 두는 것이다.

### 1-1-2 경량 모듈
* Node.js는 프로그램 코드를 구성하는 기본적인 수단으로 모듈 개념을 사용한다.
* Node.js에서 가장 널리 통용되는 원칙 중 하나는 코드의 양 뿐 아니라 범위의 측면에서도 작은 모듈을 디자인 하는 것이다.
* Node.js는 패키지 관리자의 도움을 받아 각 패키지가 자신이 필요로 하는 버전의 종속성 패키지들을 갖도록 함으로써 종속성 지옥에서 벗어나게 해준다.

작은 모듈은 재사용성이라는 장점 외에도 다음의 장점이 있다.
* 이해하기 쉽고 사용하기 쉽다.
* 테스트 및 유지보수가 쉽다.
* 사이즈가 작아 브라우저에서 사용하기에 완벽하다.

### 1-1-3 작은 외부 인터페이스
* Node.js 모듈들이 갖는 장점은 작은 사이즈와 작은 범위 그리고 최소한의 기능 노출이다.
* Node.js에서 모듈을 정의하는 가장 일반적인 패턴은 명백한 단일 진입점을 제공하기 위해서 단 하나의 함수나 클래스를 노출시키는 것이다.

### 1-1-4 간결함과 실용주의
* 실제로 복잡한 클래스 계층을 대체하기 위해서 간단한 클래스나 함수 그리고 클러저를 사용하는 것을 쉽게 볼수 있다.

## 1-2 Node.js는 어떻게 작동하는가?
* Node.js가 내부적으로 어떻게 동작하는지 이해하게 될 것이며 Node.js가 가진 비동기 특성의 핵심인 리액터 패턴에 대해서 소개를 받을 수 있다.

### 1-2-1 I/O는 느리다
* RAM에 접근하는 데에는 나노초(10^-9초)인 반면, 디스크와 네트워크에 접근하는 데에는 밀리초(10^-3초)가 걸린다.

### 1-2-2 블로킹 I/O
* 전통적인 블로킹 I/O 프로그래밍에서는 I/O를 요청하는 함수의 호출은 작업이 완료될 때까지 스레드의 실행을 차단합니다.
* 이 문제를 해결하기 위해 전통적인 접근 방법은 각각의 동시 연결을 처리하기 위해서 개별의 스레드 또는 프로세스를 사용하는 것입니다.
* 메모리를 소모하고 컨텍스트 전환을 유발하여 대부분의 시간 동안 사용하지 않는 장시간 실행 스레드를 가지게 됨으로써 귀중한 메모리와 CPU 사이클을 낭비하게 됩니다.

### 1-2-3 논 블로킹 I/O
* 이 운영모드에서 시스템 호출은 데이터가 읽혀지거나 쓰여지기를 기다리지 않고 항상 즉시 반환됩니다.
* 호출 순간에 사용 가능한 결과가 없는 경우, 함수는 단순히 미리 정의된 상수를 반환하여 그 순간에 사용 가능한 데이터가 없다는 것을 알립니다.
* 바쁜 대기(busy-waiting)라고 불리는 것을 통해 실제 데이터가 반환될 때까지 루프 내에서 리소스를 적극적으로 폴링합니다.
* 하지만 폴링 알고리즘은 엄청난 CPU 시간의 낭비를 초래합니다.

### 1-2-4 이벤트 디멀티플렉싱
* 바쁜 대기는 논 블로킹 리소스 처리를 위한 이상적인 기법이 아니다.
* 대부분의 운영체제는 논 블로킹 리소스를 효율적인 방법으로 처리하기 위한 기본적인 메커니즘을 제공한다.
* 동기 이벤트 디멀티플렉서 또는 이벤트 통지 인터페이스라고 한다.
* 하나의 스레드만 가지는 것은 일반적으로 프로그래머가 동시성에 접근하는 방식에 이로운 영향을 미치게 됩니다.
* 해당 책을 통해 Race Condition(경쟁 상태)의 발생 문제와 다중 스레드의 동기화 문제가 없다는 것이 어떻게 우리에게 더 간단한 동시성 전략을 사용하게 해줄 수 있는지 확인할 수 있다.

### 1-2-5 리액터 패턴
* 리액터 패턴의 이면에 있는 주된 아이디어는 각 I/O 작업에 연관된 핸들러를 갖는다는 것이다. Node.js에서의 핸들러는 콜백 함수에 해당한다.
* Node.js 애플리케이션은 이벤트 디멀티플렉서에 더 이상 보류중인 작업이 없고 이벤트 큐에 더 이상 처리 중인 작업이 없을 경우 종료된다.
* Reator 패턴은 일련의 관찰 대상 리소스에서 새 이벤트를 사용할 수 있을 때까지 블로킹하여 I/O를 처리하고, 각 이벤트를 핸들러에 전달함으로써 반응한다.

### 1-2-6 Libuv, Node.js의 I/O 엔진
* 각 I/O 작업은 동일한 OS 내에서도 리소스 유형에 따라 매우 다르게 동작할 수 있습니다.
* Unix에서 일반 파일 시스템은 논 블로킹 작업을 지원하지 않기 때문에 논 블로킹 동작을 위해서는 이벤트 루프 외부에 별도의 스레드를 사용해야 합니다.
* 따라서 서로 다른 운영체제 간의 불일치성은 이벤트 디멀티플렉서를 위해 보다 높은 레벨의 추상화를 필요로 하게 되었다.
* 서로 다른 리소스 유형의 논 블로킹 동작을 표준화하기 위해 Libuv라고 불리는 C 라이브러리를 만들었다.
* Libuv는 기본 시스템 호출을 추상화하는 것 외에도 리액터 패턴을 구현하고 있으므로 이벤트 루프의 생성, 이벤트 큐의 관리, 비동기 I/O 작업의 실행 및 다른 유형의 작업을 큐에 담기 위한 API들을 제공한다.

### 1-2-7 Node.js를 위한 구성
* 리액터 패턴과 Libuv는 Node.js의 기본 구성 요소지만 전체 플랫폼의 구축을 위해서는 3개의 구성이 더 필요하다.
* 바인딩 세트, V8, 고수준 Node.js API를 구현하고 있는 코어 JavaScript 라이브러리
