1장

논점

## 1. 사용자 정의 오류 vs 표준 오류 사용

쿠마 : 사용자 정의 오류를 사용하면 보다 빠르게 찾을 수 있다.
찰스 : 이미 있는 표준 라이브러리가 있다면 재사용을 해라로 나와있음
서비스 지향적인 팀은 사용자 정의 오류를 선호하는 것 같다.
엔지니어링팀은 소스 자체를 들여다보는것을 선호
올리브 : Go, 신생 언어들은 에러 체계가 잘 안잡혀있다.

예외자체는 좋은 건 아니다.
=> C에서는 오류를 어떻게 처리했는지를 알면 
Go to 가 갖는 에러를 해결하려고 만들었는데
예외자체를 염두해두고 책을 읽으면 이해되는 부분이 있다 
예외는 안쓰는게 좋다.

프로그래밍 관점에서 보면 Failure~ 이게 맞다.

Top - down

Rule 1 - Nested Rule
Rule 2 - selection Rule
Rule 3 - Overlays Rule 

절차지향적 언어 C 

flow chart 

pro1
pro2

2개의 영역이 겹치면 안된다는 법칙

go to 가 layer 중첩의 원인이 되기 때문에 쓰지 마라

스파게티 코드? => 단순 가독성이 낮은 코드라는 의미로 쓰이기도 함. 책에서는 오버레이되는 코드라고 지칭함.

## 2.단위 테스트를 어떻게 사용하는지

TDD를 옹호하진 않지만, 무엇을 테스트할 것인가. -> 생산성, 코드 안정성
`무엇을 테스트할 것인가?`
효용성0인데 리소스가 20이 추가되면 테스트에 대한 경험이 안좋아진다.


## 3.npe를 방어가능한가?

## 4.immutable collection

copy 를 제외하면 성능상 이슈가 사라지는것인가?

imuutable collection += => 복사가 안되는게 정상

immutable linked list

스칼라가 도입되면서 -> 기존 레거시 코드와의 통합이 어려워짐

## 5. immutable에서 muttble 객체를 만들지 말라
상태를 쓰지말라고하면 객체지향적이지 않을까?

## 6. 어떤 의미로 null을 쓰는 경우가 있는지?

Optional 

올리브 : null은 잠정적 위험 요소, null을 의미있게 사용한다? 

if null 은 잘못된 방식

스터디 방식 : 금요일까지 개인 해석을 정리, 스터디 전날까지 금주 맡은 인원이 아젠다를 적극적으로 올리고 나머지 인원은 추가하는 형태로 진행.

담당자가 정리하여 업로드.

아젠다 리스트를 보고 skip 할 수 있다면 skip


