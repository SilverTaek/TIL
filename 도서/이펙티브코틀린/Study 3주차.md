Kuma : 저자가 기술에 대해서 설명해줄 때 쉽게 설명해주는 부분이 있어서 이해가 잘되지만, 이 기술이 현재 주제와 연관성에 대해서 감이 잘오지는 않는다. 그 외 이론적인 부분은 반박하거나 이견이 나오는 그런 주제들이여서 "당연하지"라고 느끼면서 읽었다. 결론적으로 테그니컬한 부분을 좀 집중적으로 봐야한다고 느꼈다.

Olive : 책 전반적으로 코틀린에 대해서 재사용을 어떻게 활용하면 좋은지에 대해서 이견은 없다. 제네릭같은 경우 재사용 파트에서 설명해도 좋지만 해당 부분은 따로 챕터로 빼서 디테일하게 설명해줬으면 더 좋았을 것 같다. 코틀린에서 재사용성에 대한 좋은 예제들을 조금 더 넣어줬으면 어땠을까라는 생각이 들었다.

charles : 큰 주제를 다루는데 방향성에 대한 부분이 부족한 것 같다. Item에 대한 설명이 더 있었으면 좋을 것 같다.

## 아젠다

1. Kotlin으로 풀스택 개발하기 vs 백엔드, 프론트 분리하여 개발하기

Kotlin으로 풀스택 개발하기

Olive : 생산성 문제, 이점들을 커버할 만큼의 장점이 있는지를 정확하게 따져봐야할 것 같다.
Kuma : front가 back 보다 빠르게 발전하기 때문에 코틀린이 경쟁력이 있을지에 대한 의문이 있다.
charles : 개발자 풀 문제, 트러블 슈팅할 수 있는 레벨이 되기는 힘들 것 같다. 현실적으로는 힘들 것 같다.


2. 재사용성을 저해하는 것들은 무엇이 있을까?

* 재사용성이 필요할까?

olive : 상황에 따라서 다를 것 같다. 재사용성이 떨어진다는 건 중복이 많이 발생할 수 있다는 관점에서 봤을 때, => 복붙 

charles : 중복이 발생할 수록 재사용성이 올라간다.

Kuma : 어쩔 수 없이 재사용성을 침해하면서 코드를 작성할 때가 있는 것 같다. ex) 단발성 이벤트 같은 경우 실제 베이스가 된 실제 서비스에서 필요가 없는 경우가 있다. 예를들어 3일만 진행하는 이벤트, 기존에 있는 로직을 가져오다보니 유지보수 측면에서 안좋았다.

charles : 재사용에 대해서 명확하게, 로직이 같다고 같은 건 아니다. A, B가 같은 동작을 한다고 같은 건 아니다. Kuma님의 예제는 2개의 knowledge가 있다. kuma님의 예제 접근 방법이 올바른 방법이다.

kuma : 동작과 기능이 똑같다면 재사용을 할 수 밖에 없지 않나

charles : 20%의 코드가 80%의 성능을 발휘한다. -> 컴퓨터 공학에서는 함수 호출의 비용을 '0'로 가정한다. 재귀도 같은데, 현실에서 재귀를 하고 20%에 해당된다면 성능이 많이 낭비가 된다. 구조적으로는 좋지만, 20%의 코드에 해당되면 루프로 바꿔야한다.

### Q. 언제부터 재사용성에 대해서 관심이 갖게 되었을까?

제일 처음의 컴퓨터 -> 애니악

애니악은 미사일 궤도를 계산하기 위한 용도로 나왔음.

각각 컴파일을 한 다음 링크라는 것을 한게 C언어

큰 프로그램을 만들 때 생기는 문제를 해결하기 위해서 재사용성에 대해서 관심을 가지게 되었음

### Q. 파일을 왜 나누는것이 왜 중요할까?

컴파일 타임이 굉장히 오래걸린다.

파일이 커지면, 연산을 해야한다. 컴파일 타임에 앞에서부터 실행하는게 아니라 jump 등 에 대한 연산도 필요하기 때문에 현재 위치에서 offset 계산을 하려면 뒤를 읽어야지 어디로 jump할 수 있는지 address를 알 수 있다.

결론적으로 jump 등과 같은 것들에 의해서 컴파일 타임이 결정된다. 이러한 것들을 해결하기 위해서 파일을 나눈다.

프로그램이 커지면 재사용성이 필요하고, 작으면 필요없다.


## Re) 재사용성을 저해하는 것들은 무엇이 있을까?

olive : SOLID에서 SRP라는 요소가 있는데, 역할과 책임이 잘분리가 되어 있어야하고 공통적인 요소를 잘뽑아낼 수 있어야하는데 예를들어 하나의 메소드가 너무 많은 책임을 가지고 있을 때, 재사용성을 저해한다고 생각한다.

그렇다면 책임을 분리를 하면, 재사용성이 올라가는가?

kuma : 제대로 된 기획이 이루어지지 않은채 진행이 되거나, 변경이 많이 되는 구조라면 재사용성이 저해된다고 생각한다.

charles : 공학적인 측면) 컴퓨터 사이언스에서 풀고 싶어하는 제1문제는 무엇일까?? -> P-NP 문제, 복잡성을 푸는 것이 공학이 하는 것이다.
복잡성이란 A가 증가할 때, B가 선형이상으로 증가할 때 복잡성이 증가한다고 정의했다.

복잡성이란 왜 나오는 것인가?
=> 의존성. 의존에 의해서 복잡성이 발생한다. 알고리즘이 어디에 의존하냐에 따라서 그래프의 모양이 다르다.

의존성이 재사용성과 어떤 연관이 있는가?
=> A함수가 B를 사용하는 것과, A함수가 C함수를 사용한다고 했을 때, 재사용한다고 정의한다.
=> A는 B와 C에 의존한다. 
=> 의존성 다음이 SOLID 
=> 결론적으로, `의존성이 올바르지 않으면 재사용성을 저해한다.`

* 이기적 유전자

* 코드 컴플리트

* 클린 아키텍처

코틀린의 또 다른 장점) 유비쿼터스 언어로 쓸만한 언어인 것 같다. 아이디어를 표현해야하는데 예전에는 UML, ER다이어그램으로 표현했지만, java로 하면 굉장히 번거롭고 타이핑이 많아서 머릿속의 속도를 못따라간다. 하지만 코트린으로 표현하면 좋다. 따라서 Front, Back 을 개발할 때에도 아이디어 단계부터 재사용이 가능해서 좋음

SOLID가 나중에는 필요가 없다. -> 비공학적인 개발자들을 위한 내용

리스코프 치환 원칙에 따라 개발을 했는데, 왜 문제가 발생하는지?