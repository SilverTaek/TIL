## Question1) Socket 으로 바로 통신하는 것 대비 HTTP 는 비효율적인데도 왜 많은 앱들은 HTTP 를 쓰는 걸까요?

기본적으로 Socket 과 HTTP는 사용 용도가 다르다고 생각합니다. 기본적으로 Socket은 양방향 통신, HTTP는 단방향 통신이기 때문에 실시간 통신이 필요할 때는 Socket을 사용합니다. 이는 클라이언트와 서버가 상시 연결되어 있기 때문에 서버 부하가 발생할 수 있다는 단점이 있고, HTTP는 클라이언트가 요청이 들어올 때만 통신하기 때문에 Socket 통신에 비하여 통신 비용이 적다고 생각해서 많은 앱들이 HTTP를 사용한다고 생각합니다.

또한 Socket 같은 경우 최대 커넥션이 넘을 경우 강제로 연결이 끊어질 수 밖에 없으며 다시 연결해야한다는 단점이 있고, HTTP는 일회성 연결이기 때문에 신경쓰지 않아도 된다는 장점이 있다고 생각합니다.

또한, 최근 대규모 트래픽에 대응하기 위해 서버를 증설하는 Scale-Out 형태에서 연결을 지속해야 하는 socket은 문제가 발생할 여지가 많아서 많은 앱들에서 HTTP 통신을 사용한다고 생각합니다

## Question2) OSI Layer 7 또는 TCP Model 에 대해 설명해주세요.

OSI7 계층이 생긴 이유 : 국제표군기구 iso가 발표한 네트워크 모델
A라는 회사가 만든 네트워크 장비들에서 장비들 사이에서 통신이 원활하게 이루어지지만 다른 규격을 사용하고 있는 B라는 회사와 통신하려하니 원활한 통신이 이루어지지 않기 때문에 규격을 맞추기 위해  OSI 모델이 생겼습니다.

osi 모델은 7계층으로 나뉘는데 먼저 7계층은 어플리케이션 계층이며 응용프로세스를 직접 사용하여 응용 서비스를 사용하는 계층인데 저희가 사용하고있는 FTP, HTTP, SMTP, Telnet 과 같은 프로토콜들이 속한 계층이라고 생각하면 됩니다.

6계층은 프레젠테이션 계층인데, 데이터의 변환, 데이터의 압축 그리고 데이터 암호화가 이루어집니다.

서로 다른 통신 기기 간에 다른 인코딩을 사용할 수 있기때문에 해당 계층에서 데이터 변환이 이루어진다.

세션 계층은 세션을 열고 닫고를 제공하는 메커니즘의 계층입니다.
세션 복구도 지원을 하는데, 세션 도커는 체크포인트라는 것을 통해 동기화를 시켜준다.

컴퓨터 A에서 B로 100MB 데이터를 전송한다고 햇을 때 체크포인트를 5MB를 설정한다고 가정하면 48BM 전송하는 도중에 연결이 끊기면 체크포인트 덕분에 다시 45MB로 세션을 재개할 수 있다.

트랜스포트계층은 서로 다른 두 네트워크간의 전송을 담당하는 계층입니다.

트랜스포트 계층은 세그멘테이션, 흐름제어 , 오류제어등을 제공한다.

세그멘티이션은 상위 계층 데이터를 받아서 세그먼트라는 단위로 나누는 것을 의밓한다.

이런 세그멘테이션 작업을 하는 이유는 한 컴퓨터에서 데이터를 100MB전 송한다고 봤을 때 세그멘테이션을 안하면 100MB가 다 로딩되고 나서야 비디오를 볼 수 있다.

하지만 이걸 사용하면 비디오 일부분을 볼 수 있고 그만큼 유쾌한 경험이 될 수 있다.

그리고 연결이 중간에 끊기게 되면 세그를 안하면 큰 데이터가 다날라가니 손실율이 높다고 볼 수 있다.

흐름제어는 서로 다른 데이터 전송량이 다른 기기에서 전송량을 낮추는 방식 or 높이는 방식

정확히는 Stop & wait 방식을 사용

오류제어는 내가 보낸 데이터가 오류 손실이 없는지 오류가 있다면 다시 해당 데이터를 보내주는 FEC BEC ARQ와 같은 방식들이 있다.

네트워크 계층은 IP나 라우터 장비가 속한 계층이다 데이터의 전송을 담당하는데 호스트에 IP번호를 부여하고 해당 도착지 IP까지 최적의 경로를 찾아주는 기능을 제공하는데 이런것을 라우팅이라고한다.

데이터 링크 계층은 네트워크 계층과 상당히 유사한데 차이점은 네트워크 계층은 서로 다른 네트워크를 담당하고, 데이터 링크 계층은 동일한 네트워크를 담당한다. 데이터 링크 계층도 오류제어와 흐름제어를 제공한다.

물리계층은 이런 비트 단위들을 전기신호로 변환하고 전송하는 것을 담당하고있다.


결론적으로 현재 저희가 사용하는 모델은 OSI Model이 아니라 TCP/IP 모델을 사용하고 있다.

현재 OSI 모델은 네트워크를 묘사해주기위한 모델이고, OSI 모델의 세션 계층과 프레젠테이션 계층이 어플리케이션 계층으로 통합되어 있다




OSI7 계층이 생긴 이유 : 국제표군기구 iso가 발표한 네트워크 모델
A라는 회사가 만든 네트워크 장비들에서 장비들 사이에서 통신이 원활하게 이루어지지만 다른 규격을 사용하고 있는 B라는 회사와 통신하려하니 원활한 통신이 이루어지지 않기 때문에 규격을 맞추기 위해  OSI 모델이 생겼습니다.

osi 모델은 7계층으로 나뉘는데 먼저 7계층은 어플리케이션 계층이며 응용프로세스를 직접 사용하여 응용 서비스를 사용하는 계층인데 저희가 사용하고있는 FTP, HTTP, SMTP, Telnet 과 같은 프로토콜들이 속한 계층이라고 생각하면 됩니다.

6계층은 프레젠테이션 계층인데, 데이터의 변환, 데이터의 압축 그리고 데이터 암호화가 이루어집니다.

서로 다른 통신 기기 간에 다른 인코딩을 사용할 수 있기때문에 해당 계층에서 데이터 변환이 이루어진다.

세션 계층은 세션을 열고 닫고를 제공하는 메커니즘의 계층입니다.
세션 복구도 지원을 하는데, 세션 도커는 체크포인트라는 것을 통해 동기화를 시켜준다.

컴퓨터 A에서 B로 100MB 데이터를 전송한다고 햇을 때 체크포인트를 5MB를 설정한다고 가정하면 48BM 전송하는 도중에 연결이 끊기면 체크포인트 덕분에 다시 45MB로 세션을 재개할 수 있다.

트랜스포트계층은 서로 다른 두 네트워크간의 전송을 담당하는 계층입니다.

트랜스포트 계층은 세그멘테이션, 흐름제어 , 오류제어등을 제공한다.

세그멘티이션은 상위 계층 데이터를 받아서 세그먼트라는 단위로 나누는 것을 의밓한다.

이런 세그멘테이션 작업을 하는 이유는 한 컴퓨터에서 데이터를 100MB전 송한다고 봤을 때 세그멘테이션을 안하면 100MB가 다 로딩되고 나서야 비디오를 볼 수 있다.

하지만 이걸 사용하면 비디오 일부분을 볼 수 있고 그만큼 유쾌한 경험이 될 수 있다.

그리고 연결이 중간에 끊기게 되면 세그를 안하면 큰 데이터가 다날라가니 손실율이 높다고 볼 수 있다.

흐름제어는 서로 다른 데이터 전송량이 다른 기기에서 전송량을 낮추는 방식 or 높이는 방식

정확히는 Stop & wait 방식을 사용

오류제어는 내가 보낸 데이터가 오류 손실이 없는지 오류가 있다면 다시 해당 데이터를 보내주는 FEC BEC ARQ와 같은 방식들이 있다.

네트워크 계층은 IP나 라우터 장비가 속한 계층이다 데이터의 전송을 담당하는데 호스트에 IP번호를 부여하고 해당 도착지 IP까지 최적의 경로를 찾아주는 기능을 제공하는데 이런것을 라우팅이라고한다.

데이터 링크 계층은 네트워크 계층과 상당히 유사한데 차이점은 네트워크 계층은 서로 다른 네트워크를 담당하고, 데이터 링크 계층은 동일한 네트워크를 담당한다. 데이터 링크 계층도 오류제어와 흐름제어를 제공한다.

물리계층은 이런 비트 단위들을 전기신호로 변환하고 전송하는 것을 담당하고있다.


결론적으로 현재 저희가 사용하는 모델은 OSI Model이 아니라 TCP/IP 모델을 사용하고 있다.

현재 OSI 모델은 네트워크를 묘사해주기위한 모델이고, OSI 모델의 세션 계층과 프레젠테이션 계층이 어플리케이션 계층으로 통합되어 있다.


## Question3) 차세대 프로토콜로 논의중인 HTTP/3 은 UDP 기반의 QUIC 이라는 기술로 구현되어 있습니다. UDP 는 TCP 대비 안정성이 떨어지는 프로토콜이라고 하는데, 그럼에도 왜 UDP 를 채택한 걸까요?


먼저, TCP와 UDP의 차이에 대해서 알아야하는데 일반적으로 TCP는 신뢰성이 높고 느리다, UDP는 신뢰성이 낮고 빠르다 정도로 정리가 된다. TCP는 클라이언트와 서버가 서로 신뢰성있는 통신을 할 수 있도록 몇 가지 방법을 사용하게 되는데, 이 방법들 또한 결국은 클라이언트와 서버 간의 통신이기 때문에 레이턴시가 발생할 수 밖에 없다. 게다가 이 과정은 TCP라는 프로토콜이 생길 때부터 정의된 표준이므로 무시할 수 도 없다.

기술이 발전하면서 전송해야하는 데이터의 크기도 점점 커지기 때문에 결국 언젠가는 또 느려지고, 회선의 전송 속도 자체를 높힌다고 해도 결국은 빛의 속도 보다 빠르게 전송할 수 없기 때문에 한계가 있다. 

HTTP/3이 UDP 기반인 QUIC 프로토콜을 사용하는 이유가 바로 이런 제약 조건을 뛰어넘기 위해 프로토콜 자체를 손보는 방법을 택한 것이다. 하지만 TCP는 워낙 오래된 프로토콜이기도 하고 커널까지 내려가는 로우 레벨에서 정의되어 있기 때문에 이걸 뜯어고치는 것도 만만치 않은 대작업이라 UDP를 선택한 것이다.

그렇다면, TCP가 신뢰성 있는 통신을 위해 사용하는 방법들이 왜 느릴까?

## HOLB(Head of line Blocking)
HTTP 레벨에서의 HOLB와 TCP 레벨에서의 HOLB는 다른 의미이기는 하나 결국 어떤 요청에 병목이 생겨서 전체적인 레이턴시가 늘어난다는 맥락으로 본다면 동일하다고 볼 수 있다.

TCP를 사용한 통신에서 패킷은 무조건 정확한 순서대로 처리되어야 한다. 수신 측은 송신 측과 주고받은 시퀀스 번호를 참고하여 패킷을 재조립해야하기 때문이다.

그래서 통신 중간에 패킷이 손실되면 완전한 데이터로 다시 조립할 수 없기 때문에 절대로 그냥 넘어가지 않는다. 무조건 송신 측은 수신 측이 패킷을 제대로 다 받았다는 것을 확인한 후, 만약 수신 측이 제대로 패킷을 받지 못했으면 해당 패킷을 다시 보내야 한다.

또한 패킷이 처리되는 순서 또한 정해져있으므로 이전에 받은 패킷을 파싱하기 전까지는 다음 패킷을 처리할 수도 없다. 이렇게 패킷이 중간에 유실되거나 수신 측의 패킷 파싱 속도가 느리다면 통신에 병목이 발생하게 되는 현상을 HOLB라고 부른다.

HTTP/3는 QUIC를 기반으로 돌아가는 프로토콜이기 때문에 우리가 HTTP/3를 이해하려면  QUIC에 초점을 맞춰야한다. QUIC은 TCP가 가지고 있는 이런 문제들을 해결하고 레이턴시의 한계를 뛰어넘고자 구글이 개발한 UDP 기반의 프로토콜이다.

QUIC은 처음부터 TCP의 핸드쉐이크 과정을 최적화하는 것에 초점을 맞추어 설계되었고, UDP를 사용함으로써 이를 실현해낼 수 있었다.

그렇다면 UDP를 사용하게 되면 기존의 TCP가 가지던 신뢰성과 패킷의 무결함도 함께 사라지는 걸까? 아니 그렇지 않다. UDP를 사용하더라도 기존의 TCP가 가지고 있던 기능을 전부 구현할 수 있다. UDP의 진짜 장점은 커스터마이징이 용이하다는 것이다.

참조 : https://evan-moon.github.io/2019/10/08/what-is-http3/

## Question4) SSL (또는 TLS) 가 어떻게 동작하는지 말씀해주세요.

#### SSL 동작방식

SSL 인증성 관련 프로세스에는 다음과 같은 보안 기술이 탑재되어 있다.

* 하나의 키로 암호화/복호화를 수행하는 대칭키 암호화 방식

* 한 쌍의 키 페어로 암호화/복호화를 수행하는 비대칭키 암호화 방식

* 통신 대상을 서로가 확인하는 신분 확인

* 믿을 수 있는 SSL 인증서를 위한 디지털 서명

* 디지털 서명을 해주는 인증 기관

* 공개키를 안전하게 전달하고 공유하기 위한 프로토콜

* 암호화 된 메시지의 변조 여부를 확인하는 메시지 무결성 알고리즘

#### 대칭키 암호화 방식 
대칭키 암호화 방식이란 하나의 키로 평문을 암호화하고, 다시 암호문을 원래의 평문으로 복호화할 때 사용하는 방식이다. 대문을 잠그는 자물쇠를 떠올려보면, 자물쇠를 잠근 열쇠만이 그 자물쇠를 다시 열 수 있듯이 잠그고 여는 것 모두가 하나의 열쇠를 사용한다.

대칭키 암호화 방식은 키를 단 하나만 사용하는 간편함이 있지만, 키를 분실하거나 누군가에게 도난당하면 내 암호문을 누군가가 복호화하여 볼 수 있다는 치명적인 단점이 있다.

#### 공개키 암호화 방식
공개키 암호화 방식은 공개키, 개인키 이렇게 두 개의 키를 한쌍으로 각각 암호화/복호화에 사용한다. 일반적으로 공개키로 암호화한 것을 개인키로 복호화한다. 개인키를 먼저 만들고 여기서 공개키를 파생하여 한 쌍의 키를 만들기 때문에 key pair라 부른다. 만약 같은 쌍이 아닌 다른 키를 사용하려 한다면 암호화/복호화가 불가능하다.

공개키 방식은 대칭키 방식에 비해 안전하지만, 계산 과정이 복잡하고 연산 도중 컴퓨터의 자원이 많이 사용하기 때문에 실제 IT시스템에서는 공개키 방식과 대칭키 방식을 적절히 혼합하여 사용한다.

#### SSL 핸드 쉐이크 과정

1) 클라이언트가 먼저 서버에 접속한다.
HTTPS를 사용하는것을 알게 된 브라우저는 다음 정보를 클라이언트에게 보낸다.
* 브라우저가 사용하는 SSL 혹은 TLS 버전 정보
* 브라우저가 지원하는 암호화 방식 모음
* 브라우저가 순간적으로 생성한 임의의 난수
* 만약 이전에 SSL 핸드 쉐이크가 완료된 상태라면, 그때 생성된 세션 아이디
* 기타 확장 정보

2) 서버 또한 위의 인사에 응답하면서, 다음 정보를 클라이언트에 제공한다.
* 브라우저의 암호화 방식 정보 중에서, 서버가 지원하고 선택한 암호화 방식
* 서버의 공개키가 담긴 SSL 인증서, 인증서는 CA의 비밀키로 암호화되어 발급된 상태
* 서버가 순간적으로 생성한 임의의 난수
* 클라이언트 인증서 요청(선택)

3) 브라우저는 서버의 SSL 인증서가 믿을만한지 확인
* 대부분 브라우저에는 공신력 있는 CA들의 정보와 CA가 만든 공개키가 이미 설치되어 있다.

4) 브라우저는 자신이 생성한 난수와 서버의 난수를 사용하여 premaster secret을 만든다.
* 웹 서버 인증서에 딸려온 웹 사이트의 공개키로 이것을 암호화하여 서버로 전송한다.

5) 서버는 사이트의 비밀키로, 브라우저가 보낸 premaster secret 값을 복호화한다.

* 복호화 한 값을 master secret 값으로 저장한다. 이것을 사용하여 방금 브라우저와 만들어진 연결에 고유한 값을 부여하기 위한 session key를 사용한다.

6) SSL handshake를 종료하고, 드디어 HTTPS 통신을 시작한다. 

참조 : https://brunch.co.kr/@sangjinkang/38

추가) TLS는 Transport Layer Security의 전송 계층 보안이라는 약자이다.

기본적으로 TCP의 443포트를 사용한다.

TLS가 있기 전 SSL 기술이 있었다.

TLS가 가진 특징은 암호화, 인증, 무결성

## Question5) HTTP 는 Stateless (상태가 없는) 통신 프로토콜이라고 합니다. 따라서, 상태가 없다면 가령 HTTP 를 쓰는 서비스는 매번 로그인을 해 줘야 하거나 사용자 정보를 저장하는 일이 불가능합니다. 그런데 실제론 그렇지 않죠. 어떻게 이런 불편함을 해소했을까요?
총 3가지 방법으로 해결할 수 있습니다.
1. 쿠키
쿠키는 키-밸류 형태로 웹 브라우저의 쿠키 저장소에 저장된다. 서버로부터 쿠키를 전달받은 웹 브라우저는 이후 웹 서버에 요청을 보낼 때 쿠키를 헤더에 실어서 함께 전송합니다. 이를 활용하면 웹 서버와 클라이언트는 필요한 값을 공유하고 상태를 유지할 수 있다.

하지만 쿠키는 네트워크를 통해 전달되기 때문에 중간에 쿠키를 탈취할 수 있다는 취약점이 있다.

2. 세션
클라이언트의 상태를 저장할 수 있는데 쿠키와 다른 점은 쿠키는 각 브라우저의 별도 쿠키 저장소에 저장되는 반면에 세션은 서버에 저장된다.

3. 토큰

JWT는 인증에 필요한 정보들을 암호화시킨 토큰을 의미한다. 위의 세션/쿠키 방식과 유사하게 사용자는 Access Token을 HTTP 헤더에 실어 서버에 전송한다. 토큰은 임의로 생성된 비밀번호 같이 동작한다. 제한된 수명을 가지고, 새로운 토큰은 한번 만료되면 새로 생성되어야한다.

참조
https://hyuntaeknote.tistory.com/3
https://tofusand-dev.tistory.com/89

## Question6) 웹 브라우저에 https://www.google.com URL 을 입력 후 enter 를 쳤을 때 일어나는 과정을 최대한 상세하게 설명해주세요.

질문 내용에 답이 정해져 있는 것 같아서 아래 블로그에서 그대로 가져왔습니다.

1. URL 해석
문법에 맞지 않다면, 기본 검색엔진으로 검색한다. 주소창에 검색어를 입력했을 때 구글, 네이버 등으로 리다이렉트 되어지는 것이다.

문법에 맞다면, URL의 호스트 부분을 인코딩한다. HSTS(HTTP Strict Transport Security) 목록을 확인하고 있으면 HTTPS로 없으면 HTTP로 요청한다.

2. Browser에 캐싱된 DNS 기록들을 확인, www.google.com 에 대응하는 IP 주소가 있는 지 확인한다.
DNS(Domain Name System)의 목적은 편의성 제공이며 캐싱은 네트워크 트래픽을 조절하고 데이터 전송 시간을 줄인다.

가장 먼저 브라우저 캐시를 확인한다. 브라우저는 일정기간 동안(유저가 이전에 설정한)의 DNS 기록들을 저장하고 있다. DNS query가 이 곳에서 가장 먼저 실행이 된다.

그 다음에 브라우저는 OS 캐시를 확인한다. 브라우저 캐시에 웹사이트 이름의 IP 주소가 발견되지 않았다면, 브라우저는 systemcall을 통해서 OS가 저장하고 있는 DNS 기록들의 캐시에 접근한다.

그 다음에는 router 캐시를 확인한다. 컴퓨터에 DNS 기록을 찾지 못하면 브라우저는 DNS 기록을 캐싱하고 있는 router와 통신을 해서 찾으려고 한다.

그래도 못 찾는다면 마지막으로, ISP 캐시를 확인한다. ISP는 DNS 서버를 구축하고 있고 브라우저가 마지막으로 DNS 기록이 있기를 바라며 접근하게 된다.

3. 요청한 URL이 캐시에 없으면, ISP의 DNS 서버가 www.google.com을 호스팅하고 있는 서버의 IP 주소를 찾기 위해 DNS query를 날린다 

DNS query의 목적은 여러 다른 DNS 서버들을 검색해서 해당 사이트의 IP 주소를 찾는 것이다. 이러한 검색을 recursive search라고 부른다. IP 주소를 찾을 때 까지 DNS 서버에서 다른 DNS 서버를 오가면서 반복적으로 검색하던지 못 찾아서 에러가 발생할 때 까지 검색을 진행한다.

이 상황에서, ISP의 DNS 서버를 DNS recursor라고 부르고 인터넷을 통해 다른 DNS 서버들에게 물어 물어 도메인 이름의 올바른 IP 주소를 찾는데 책임을 갖고 있다. 다른 DNS 서버들은 name server라고 불린다. 이들은 웹사이트 도메인 이름의 구조에 기반해서 검색을 하기때문이다.

4. Browser가 서버와 TCP connection을 한다

HTTP 요청: TCP(Transmission Control Protocol) 소켓을 열고 3-way handshake로 연결을 설정한다. 

HTTPS 요청:  TLS(Transport Layer Security) handshake 과정을 통해 세션키를 생성한다.

브라우저가 올바른 IP 주소를 받게 되면 서버와 connection을 빌드하게 된다. 브라우저는 인터넷 프로토콜을 사용해서 서버와 연결이 된다. 인터넷 프로토콜의 종류는 여러가지가 있지만, 웹사이트의 HTTP 요청의 경우에는 일반적으로 TCP를 사용한다.

클라이언트와 서버간 데이터 패킷들이 오가려면 TCP connection이 되어야 한다. TCP/IP three-way handshake라는 프로세스를 통해서 클라이언트와 서버간 connection이 이뤄지게 된다. 단어 그대로 클라이언트와 서버가 SYN과 ACK메세지들을 가지고 3번의 프로세스를 거친 후에 연결이 된다.

클라이언트 머신이 SYN 패킷을 서버에 보내고 connection을 열어달라고 물어본다
서버가 새로운 connection을 시작할 수 있는 포트가 있다면 SYN/ACK 패킷으로 대답을 한다
클라이언트는 SYN/ACK 패킷을 서버로부터 받으면 서버에게 ACK 패킷을 보낸다

5. Browser가 웹 서버에 HTTP 요청을 한다.
TCP로 연결이 되었다면, 데이터를 전송하면 된다.
클라이언트의 브라우저는 GET 요청을 통해 서버에게 www.google.com 웹페이지(index.html)를 요구한다. 요청을 할 때 비밀 자료들을 포함하던지, form을 제출하는 상황에서는 POST 요청을 사용할 수도 있다. 이 요청을 할 때 다른 부가적인 정보들도 함께 전달이 된다:

browser identification(User-Agent 헤더)
받아들일 요청의 종류(Accept 헤더)
추갖거인 요청을 위해 TCP connection을 유지를 요청하는 connection 헤더
브라우저에서 얻은 쿠키 정보
기타 등등

6. 서버가 요청을 처리하고 response를 생성한다
서버는 웹서버를 가지고 있다(i.e. Apache, IIS...). 이들은 브라우저로부터 요청을 받고 request handler한테 요청을 전달해서 요청을 읽고 response를 생성하게 한다. Request handler란 ASP.NET, PHP, Ruby 등으로 작성된 프로그램을 의미한다. 이 request handler는 요청과 요청의 헤더, 쿠키를 읽어서 요청이 무엇인지 파악하고 필요하다면 서버에 정보를 업데이트 한다. 그 다음에 response를 특정한 포맷으로(JSON, XML, HTML) 작성한다.

7. 서버가 HTTP response를 보낸다
서버의 response에는 요청한 웹페이지, status code, compression type(Content-Encoding) - 어떻게 인코딩 되어 있는지, 어떻게 페이지를 캐싱할지(Cache-Control), 설정할 쿠키가 있다면 쿠키, 개인정보 등이 포함된다.

response의 첫줄은 status code를 나타낸다. Status code란 현재 response의 상태를 의미하고 총 5가지의 종류가 있다:

1xx은 정보만 담긴 메세지라는 것을 의미한다
2xx response가 성공적이라는 것을 의미한다
3xx 클라이언트를 다른 URL로 리다이렉트함을 의미한다
4xx 클라이언트 측에서 에러가 발생했음을 의미한다
5xx 서버 측에서 에러가 발생했음읠 의미한다

8. Browser가 HTML content를 보여준다
브라우저는 HTML content를 단계적으로 보여준다. 처음에는 HTML의 스켈레톤(기본 틀이라고 보면 될듯하다)을 렌더링한다. 그 다음에는는 HTML tag들을 체크하고 나서 추가적으로 필요한 웹페이지 요소들을(이미지, CSS 스타일시트, Javascript 파일, 등) GET으로 요청한다. 이 정적인 파일들은 브라우저에 의해 캐싱이 되서 나중에 해당 페이지를 방문할 때 다시 서버로부터 불러와지지 않도록 한다. 그 다음에는 그토록 원했던 www.google.com의 모습이 보이게 된다.

참조 : https://oizys.tistory.com/36

## Question7) HTTP(s) 프로토콜에서 바이너리 데이터를 전송하는 방식에 대해 설명해주세요.

확실하지는 않지만, 클라이언트에서 이미지 동영상 파일과 같은 바이너리 데이터를 전송할 때 Base64 인코더를 사용하여 String 형태로 변환하여 전송하는 것으로 알고 있습니다.

## Question8) Socket 으로 웹 페이지를 크롤링하는 HTTP 클라이언트를 직접 구현해야 한다면, 어떻게 하시겠습니까?

질문의 의도가 무엇인지 잘모르겠습니다!

소켓 통신할 때 주고 받는 데이터를 크롤링하는 걸까요?

