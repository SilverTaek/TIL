# 1. 인덱스란?

인덱스 == 정렬

insert, update, delete (Command)의 성능을 희생하고 대신 select(Query) 성능을 향상시킨다.

update, delete 행위가 느린 것이지, update, delete를 하기 위해 해당 데이터를 조회하는 것은 인덱스가 있으면 빠르게 조회된다.

인덱스가 없는 칼럼을 기준으로 update, delete를 하게 되면 굉장히 느리기 때문에 인덱스로 지정된 칼럼을 기준으로 진행하는 것을 추천한다.

## B-Tree 인덱스 구조

- 인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순
- 인덱스의 두번째 칼럼은 첫 번째 컬럼에 의존해서 정렬되어 있다.
  - 즉, 두번째 칼럼의 정렬은 첫번째 칼럼이 똑같은 열에서만 의미가 있다.
  - 만약 3번째, 4번째 인덱스 컬럼도 있다면 두번째 컬럼과 마찬가지로 3번째 컬럼은 2번째 컬럼에 의존하고, 4번째 컬럼은 3번째 칼럼에 의존하는 관계가 된다.
- 디스크에서 읽는 것은 메모리에서 읽는것보다 성능이 훨씬 떨어진다.
  - 결국 인덱스 성능을 향상시킨다는 것은 디스크 저장소에 얼마나 덜 접근하게 만드느냐, 인덱스 Root에서 Leaf까지 오고가는 횟수를 얼마나 줄이느냐에 달려있다.
- 인덱스의 갯수는 3~4개 정도가 적당하다.
  - 너무 많은 인덱스는 새로운 row를 등록할때마다 인덱스를 추가해야하고, 수정/삭제시마다 인덱스 수정이 필요하여 성능 이슈가 있다.
  - 인덱스 역시 공간을 차지하기 때문에 많은 인덱스들은 그만큼 많은 공간을 차지한다.
  - 특히 많은 인덱스들로 인해 옵티마이저가 잘못된 인덱스를 선택할 확률이 높다.

## 인덱스 키 값의 크기

- InnoDB는 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 한다. 인덱스 역시 페이지 단위로 관리 된다.

페이지는 16KB로 크기가 고정되어 있다.

만약 설정한 인덱스 키의 크기가 16Byte라고 하고, 자식 노드의 주소가 담긴 크기가 12Byte정도로 잡으면 , 16 \* 1024 / (32+12) = 372 로 되어 372개만 한 페이지에 저장할 수 있게 된다.

조회 결과로 500개의 row를 읽을 때 16btye일때는 1개의 페이지에서 다 조회가 되지만 , 32Byte일때는 2개의 페이지를 읽어야하므로 이는 성능 저하가 발행하게 된다.

- 인덱스의 키는 길면 길수록 성능상 이슈가 있다.
