# HTTP 프로토콜
HTTP(Hypertext Transfer Protocol)는 인터넷상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜이다.
애플리케이션 레빌의 프로토콜로 TCP/IP 위에서 작동한다.
HTTP는 어떤 종류의 데이터든지 전송할 수 있도록 설계돼 있다. 
HTTP로 보낼 수 있는 데이터는 HTML문서, 이미지, 동영상, 오디오, 텍스트 문서 등 여러종류가 있다.
하이퍼텍스트 기반으로(Hypertext) 데이터를 전송하겠다(Transfer) = 링크기반으로 데이터에 접속하겠다는 의미이다.

![image](https://user-images.githubusercontent.com/43171179/124402817-9079b080-dd6d-11eb-964c-366cf1fa4411.png)

## 클라이언트 

서버에 요청하는 클라이언트 소프트웨어(IE, Chrome, Firefox, Safari ...)가 설치된 컴퓨터를 이용한다. 

클라이언트는 URI를 이용해서 서버에 접속하고, 데이터를 요청할 수 있다.


## 서버 

클라이언트의 요청을 받아서, 요청을 해석하고 응답을 하는 소프트웨어가 설치된 컴퓨터(Apache, nginx, IIS, lighttpd) 등이 서버 소프트웨어다.

웹서버는 보통 표준포트인 80번 포트로 서비스한다.

## Connectionless & Stateless

HTTP는 Connectionless 방식으로 작동한다.
서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버린다.
기본적으로는 자원 하나에 대해서 하나의 연결을 만든다.

### 장점
불특정 다수를 대상으로 하는 서비스에 적합한 방식이다. 

수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리할 수 있다.
### 단점
연결을 끊어버리기 때문에, 클라이언트의 이전 상태를 알 수가 없다. 

이러한 HTTP의 특징을 stateless라고 하는데, Connectionless 로 부터 파생되는 특징이라고 할 수 있다. 

클라이언트의 이전 상태 정보를 알 수 없게 되면, 웹 서비스를 하는데 당장에 문제가 생긴다. 

클라이언트가 과거에 로그인을 성공하더라도 로그 정보를 유지할 수가 없다. HTTP는 cookie를 이용해서 이 문제를 해결하고 있다.

 

Cookie는 클라이언트와 서버의 상태 정보를 담고 있는 정보조각이다. 

로그인을 예로 들자면, 클라이언트가 로그인에 성공하면, 

서버는 로그인 정보를 자신의 데이터베이스에 저장하고 동일한 값을 cookie형태로 클라이언트에 보낸다. 

 

첫 요청 시 :

클라이언트 로그인 성공 then 서버 로그인정보를 자신의 DB에 저장 

(서버는 cookie를 키로하는 값을 데이터베이스에 저장하는 방식으로 "세션"을 유지한다)

and then return 쿠키 to 클라이언트 

 

클라이언트는 다음 번 요청때 cookie를 서버에 보내는데, 

서버는 cookie 값으로 자신의 데이터베이스를 조회해서 로그인 여부를 확인할 수 있다. 

 

두번쨰 요청 시 :

클라이언트 request(cookie) to server then 서버는 자신의 DB 조회 and then 로그인여부 확인

## URI(Uniform Resource Identifiers)

클라이언트 소프트웨어(IE, Chrome, Firefox, Safari ...)는 URI를 이용하여 자원의 위치를 찾는다. 

 

URI는 HTTP와는 독립된 다른 체계다. 

HTTP는 전송 프로토콜이고, URI는 자원의 위치를 알려주기 위한 프로토콜이다. 

 

Uniform Resource Identifiers 의 줄임로, World Wide Web 상에서 접근하고자 하는 자원의 위치를 나타내기 위해서 사용한다. 

자원은 HTML문서, 이미지, 동영상, 오디오, 텍스트 문서 등 모든 것이 될 수 있다.

```
https://www.ssafy.com/index.html 를 분해하여 분석해보자.

 

https : 자원에 접근하기 위해서 https 프로토콜을 사용한다.

 

www.ssafy.com : 자원의 인터넷 상에서의 위치는 www.ssafy.com이다. 

도메인은 ip 주소로 변환되므로, ip 주소로 서버의 위치를 찾을 수 있다.

 

index.html : 요청할 자원의 이름이다.
```

## Method(메서드)

메서드는 요청의 종류를 서버에게 알려주기 위해서 사용한다. 

다음은 요청에 사용할 수 있는 메서드들이다.


GET : 정보를 요청하기 위해서 사용한다. (SELECT)

POST : 정보를 밀어넣기 위해서 사용한다. (INSERT)

PUT : 정보를 업데이트하기 위해서 사용한다. (UPDATE)

DELETE : 정보를 삭제하기 위해서 사용한다. (DELETE)

HEAD : (HTTP)헤더 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.

OPTIONS : 웹서버가 지원하는 메서드의 종류를 요청한다.

TRACE : 클라이언트의 요청을 그대로 반환한다. 예컨데 echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용한다.

각 용도에 맞는 메서드가 준비돼 있음에도 GET과 POST만으로도 모든 종류의 요청을 표현할 수 있다.

명시적으로 메서드를 사용하지 않아도 웹 서비스 개발에 큰 문제는 없지만

Restful API 서버의 경우에는 GET, POST, DELETE, PUT을 명시적으로 구분한다. 

자원의 위치 뿐만 아니라 자원에 할 일 까지 명확히 명시할 수 있기 때문에, 

Open API 서버를 만들기 위해서 널리 사용한다.

## 요청데이터 포맷

 

1. 요청 메서드 : GET, PUT, POST, PUSH, OPTIONS 등의 요청 방식이 온다. ( GET )

2. 요청 URI : 요청하는 자원의 위치를 명시한다. ( URI )

 

3. HTTP 프로토콜 버전 : 웹 브라우저가 사용하는 프로토콜 버전이다.( HTTP/1.1 )

 

## 응답헤더 포맷

 

프로토콜과 응답코드 : ( HTTP/1.1 200 OK )

날짜 : ( Date: Sun, 12 Aug 2018 11:30:00 GMT )

서버 프로그램및 스크립트 정보 : ( Apache/2.2.4 (Unix) PHP/5.2.0 ) 

응답헤더에는 다양한 정보를 추가할 수가 있다. 

컨텐츠의 마지막 수정일

캐쉬 제어 방식.

컨텐츠 길이.

Keep Alive기능 설정

## 응답코드
### 1XX
정보 전달: 요청을 받았고, 작업을 진행 중이라는 의미이다. HTTP/1.0 이후 한동안 쓰이지 않아 서버도 클라이언트에 이 코드를 보내지 않았지만, 최근 101의 경우 WebSocket 등에서, 103의 경우 페이지 로드 속도를 빠르게 하기 위해서 다시 쓰이기 시작했다.[1]
100 Continue
101 Switching Protocols
102 Processing: 사용자가 수신요청을 하여 처리하고는 있지만 아직은 제대로 된 응답을 할 수 없는 상태임을 응답하는 코드이다. WebDAV 전용.
103 Early Hints: Link해더와 함께 사용되며 주로 서버가 응답을 준비하는 동안 사용자가 사전로딩(PreLoading)을 할수 있도록 하는 응답코드.
### 2XX
성공: 이 작업을 성공적으로 받았고, 이해했으며, 받아들여졌다는 의미이다. 200, 204, 206을 제외하고는 볼 일이 거의 없는 코드들이다.
200 OK: 성공적으로 처리했을 때 쓰인다. 가장 일반적으로 볼 수 있는 HTTP 상태.
201 Created: 요청이 성공적으로 처리되어서 리소스가 만들어졌음을 의미한다.
202 Accepted: 요청이 받아들여졌지만 처리되지 않았음을 의미한다.
203 Non-Authoritative Information : 응답받은 메타정보가 서버에 저장된 원본하고는 동일하지는 않지만 로컬이나 다른 복사본에서 수집되었음을 알리는 응답코드. 이 경우에도 보통은 200 OK 응답코드가 203 Non-Authoritative Information 응답코드보다 우선적으로 응답한다.
204 No Content: 성공적으로 처리했지만 컨텐츠를 제공하지는 않는다. 그냥 주소창에 about:blank 치고 접속하면 된다
205 Reset Content: 서버가 요청을 성공적으로 처리했지만 콘텐츠를 표시하지 않는다. 204 응답과 달리 이 응답은 요청자가 문서 보기를 재설정할 것을 요구한다 (예: 새 입력을 위한 양식 비우기).
206 Partial Content: 컨텐츠의 일부 부분만 제공한다. 보통 클라이언트에서 시작 범위나 다운로드할 범위를 지정한 경우 자동으로 해당 부분만 제공할 때 사용하는 코드이다.
207 Multi-Status: 여러 소스에서 여러 응답인 상태에서 적절한 정보를 사용자한테 제공할수 있도록 하는 응답코드. WebDAV 전용.
208 Already Reported: DAV 바인딩 멤버는 이미 응답의 앞 부분에 열거되어 있으며 다시 포함되지 않는다는 의미로 응답하는 응답코드. WebDAV 전용.
226 IM Used: 서버가 사용자의 GET 요청에 대한 리소소의 의무는 다했고, 현재 인스턴스에서 적용된 하나 이상의 인스턴스 조작 결과를 보낼 때 사용되는 코드이다. HTTP Delta Encoding 전용.
### 3XX
리다이렉션: 이 요청을 완료하기 위해서는 리다이렉션이 이루어져야 한다는 의미이다. 짧은 주소(단축 URL) 서비스의 경우 접속 시 301이나 302 코드를 보내고, 헤더의 location에 리다이렉션할 실제 URL을 적어 보낸다.
300 Multiple Choices(복수 응답): 서버에서 여러 개의 응답이 있음을 알릴 때 사용할 의도로 만들어졌으나, 정작 응답을 선택하는 방법은 표준화되지 않아 사용되지 않는다.
301 Moved Permanently(영구 이동): 영구적으로 컨텐츠가 이동했을 때 사용된다.
302 Found: 일시적으로 컨텐츠가 이동했을때 사용된다.
303 See Other: 서버가 사용자의 GET요청을 처리하여 다른URL에서 요청된 정보를 가져올수 있도로 응답하는 코드.
304 Not Modified: 200 다음으로 많이 볼 수 있는 HTTP 상태이다. 이 경우 보통 브라우저에 캐시되어 있는 버전을 쓴다.
305 Use Proxy(프록시 사용): 프록시를 사용하지 않으면 접근할수 없는 컨텐츠에 사용할 목적으로 만들어졌다. 이 응답 코드에는 요청자가 사용해야 하는 프록시 서버의 정보를 포함할수 있다. 다만 보안상 이유로 이 응답코드를 인식하는 브라우저는 없고 현재 사용 중지(Deprecated)된 비권장 응답코드이다.
306 (unused): 초기 HTTP/1.1까지만 해도 Switch Proxy 요청으로 다음 요청시 지정한 프록시 서버를 사용하라는 응답 코드로 초안이 각성되었으나[2] 정작 사용이 되지 않았고 지금은 305 Use Proxy 응답이 사용 중지(Deprecated)되어 문서에서 삭제, 예약코드로 있다. 이름조차 미사용(unused) 이다.
307 Temporary Redirect: 302와 동일하게 일시적인 컨텐츠 이동을 나타낼때 사용되나, HTTP 메소드의 변경을 허용하지 않는다.
308 Permanent Redirect: 301와 동일하게 영구적인 컨텐츠 이동을 나타낼때 사용되나, HTTP 메소드의 변경을 허용하지 않는다.

### 4XX
클라이언트 오류: 이 요청은 올바르지 않다는 의미이다. 여기서부터 브라우저에 직접 표출된다. 굵게 강조된 것은 자주 보이는 오류들이다.
400 Bad Request(잘못된 요청): 요청 자체가 잘못되었을 때 사용하는 코드이다.[3]
401 Unauthorized(권한 없음): 인증이 필요한 리소스에 인증 없이 접근할 경우 발생한다. 이 응답 코드를 사용할 때에는 반드시 브라우저에 어느 인증 방식[4]을 사용할 것인지 보내야 한다. 단순히 권한이 없는 경우 이 응답 코드 대신 아래 403 Forbidden을 사용해야 한다.
402 Payment Required(결제 필요): 결제가 필요한 리소스에 결제없이 접근했을 경우 발생. HTTP/1.1에서 정의되었으나 구현하지는 않고, 향후에 사용하기 위해 예약해둔 코드이다. 현재 딱히 표준조차도 존재하지 않는다. 이런 상황에서는 보통 403을 사용한다.
403 Forbidden(거부됨): 서버가 요청을 거부할 때 발생한다. 관리자가 해당 사용자를 차단했거나 서버에 index.html 이 없는 경우에도[5] 발생할 수 있다. 혹은 권한이 없을 때(로그인 여부와는 무관하다)에도 발생한다.
404 Not Found(찾을 수 없음): 찾는 리소스가 없다는 뜻으로, 가장 흔하게 볼 수 있는 오류 코드이다.
405 Method Not Allowed(허용되지 않은 방법) : PUT이나 DELETE 등 서버에서 허용되지 않은 메소드로 요청시 사용하는 코드이다.
406 Not Acceptable(받아들일 수 없음) : 요청은 정상이나 서버에서 받아들일 수 없는 요청일시 사용하는 코드이다. 보통 웹 방화벽에 걸리는 경우 이 코드가 반환된다. 하이퍼텍스트 커피 포트 제어 프로토콜(HTCPCP)에서도 쓴다
407 Proxy Authentication Required(프록시 인증 필요) : 프록시 인증이 필요할 경우 사용하는 코드이다.
408 Request Timeout(요청 시간 초과) : 요청 중 시간이 초과되었을때 사용하는 코드이다.
409 Conflict(충돌) : 사용자의 요청이 서버의 상태와 충돌하여 응답하는 코드이다.
410 Gone(사라짐) : 404와는 달리 찾는 리소스가 영원히 사라진 경우 사용하는 코드이다. 404가 그런 게 없어서 못 찾는 경우라면, 410은 있었던 것이 없어져서 못 찾는 것.
411 Length Required(길이 필요) : 사용자가 서버로 요청할때 해더에 Content-Length 필드에 값이 없이 요청해서 서버에서 응답을 거부할 때 쓰는 코드이다.
412 Precondition Failed(전제조건 실패): 사용자가 서버로 조건부 요청(Conditional Requests)을 할때 서버의 전제조건와 사용자의 전제조건이 맞지 않아 서버에서 응답 거부를 할때 쓰는 코드이다.
413 Payload Too Large(요청된 것이 너무 긺) : 요청 본문이 너무 긴 경우 발생한다. 서버 소프트웨어로 NGINX를 사용하는 경우 기본 설정 그대로 사용하면 큰 첨부파일을 올릴 때 이 오류 코드가 발생하게 된다.
414 URI Too Long(요청된 URL이 너무 긺): URL이 너무 길 때 발생한다. 구현 페이지 1 구현 페이지 2
415 Unsupported Media Type(지원하지 않는 미디어 타입): 사용자가 요청한 미디어타입이 서버에서 지원하지 않는 타입이라서 응답을 거부할 때 쓰는 코드이다.
416 Requested Range Not Satisfiable(요청범위 부적합): 요청 헤더의 Range로 지정한 범위가 잘못되었을 때 발생한다.
417 Expectation Failed(예측 실패): 요청 헤더의 Expect값이 서버에서는 적절하지 못하다는 것을 응답할때 쓰는 코드이다.
418 I'm a teapot(찻주전자로 커피를 만들 수 없음.): 하이퍼텍스트 커피 포트 제어 프로토콜(HTCPCP)(RFC 2324)[6]에서 사용되는 코드이다. 실제 구현 페이지
421 Misdirected Request(잘못된 요청): 서버로 유도된 요청된 응답을 서버에서 생성할 수 없을때 응답하는 코드로 주로 TLS 인증서가 여러개 설치된 상태에서 꼬였을 경우 뜨는 오류다. 참고
422 Unprocessable Entity(처리할 수 없는 개체): 요청을 잘 받았으나 문법 오류로 인하여 무언가를 응답할 수 없을때 사용되는 코드이다. WebDAV 전용.
423 Locked(잠김): 요청한 리소스가 잠겨있을때 뜨는 코드이다. WebDAV 전용.
424 Failed Dependency(실패한 종속성): 이전의 요청이 실패한 상태에서 지금의 요청도 실패한 경우 뜨는 코드이다. 간단히 말해 요청 연속실패. WebDAV 전용.
425 Too Early(너무 일찍요청) : 서버가 재생될 수 있는 요청을 처리하는 데 위험을 감수하지 않는다는걸 알릴때 사용되는 코드이다.[RFC8470] 클라이언트가 파이어폭스 58 이후 버전이 아닌이상 재대로 해석하지는 않는다.
426 Upgrade Required(업그레이드 필요): 클라이언트에서 보낸 요청의 프로토콜이 맞지 않아 현재 서버에서 처리할 수 없으나, 클라이언트가 프로토콜을 서버에서 지원하는 다른 프로토콜로 업그레이드 한다면 처리해 줄 수도 있는 상황에서 쓰는 응답 코드이다. 주로 서버의 응답에는 Upgrade 헤더와 필요한 프로토콜을 같이 응답한다. 보통 HTTP/1.1인 클라이언트가 HTTP/2만 지원하는 서버에서 요청할 때 뜬다.
428 Precondition Required(전제 조건 필요): 서버로 요청을 할려면 요청이 조건부이어야만 할 때 뜨는 코드이다. 사용자가 PUT 요청을 하여 서버의 값이 수정되는 동안 다른 사용자가 서버의 상태를 수정하여 발생하는 충돌인 업데이트 상실를 막기 위해서 존재하는 코드.
429 Too Many Requests(너무 많은 요청): 일정 시간 동안 너무 많은 요청을 보냈을 때 이를 거부하기 위해 사용한다. 나무위키에서는 페이지 소스(/raw/문서명) 보기를 너무 자주 요청했을 때 임시 차단을 걸기 위해 사용한다.
431 Request Header Fields Too Large(요청 헤더 필드가 너무 큼): 요청한 헤더 값이 너무 커서 서버에서 처리를 하지 않는다는 걸 응답할 때 쓰는 코드이다. 보통 크기가 큰 쿠키와 캐시가 너무 쌓여져 있는 상태에서 서버에 요청할 때 뜨는 오류이다. 그리고 사용자 에이전트 변경프로그램으로 UA를 너무 길게 설정했을 때도 나온다. 캐시 및 쿠키를 정리하면 대부분 정상적으로 서버에서 응답한다.
451 Unavailable For Legal Reasons(법적인 이유로 차단됨): 국가 검열 등, 법적인 이유로 차단되었을 경우 사용할 수 있도록 정의된 코드이다. 서버는 Link 헤더로 차단된 근거가 되는 주소를 보낼 수 있다.
### 5XX
서버 오류: 올바른 요청에 대해 서버가 응답할 수 없다는 의미이다
500 Internal Server Error(내부 서버 에러): 서버에 오류가 발생해 작업을 수행할 수 없을 때 사용된다. 보통 설정이나 퍼미션 문제. 아니면 HTTP 요청을 통해 호출한 문서가 실제 HTML 문서가 아니라 JSP, PHP, 서블릿 등의 프로그램일 경우 그 프로그램이 동작하다 세미콜론을 빼먹는 등의 각종 에러로 비정상 종료를 하는 경우 이 응답코드를 보낸다.
501 Not Implemented(요청한 기능 미지원): 서버가 요청을 수행하는데 필요한 기능을 지원하지 않는 경우 사용된다. 웬만해서는 볼 수 없다.
502 Bad Gateway(게이트웨이 불량): 게이트웨이가 연결된 서버로부터 잘못된 응답을 받았을 때 사용된다.
503 Service Temporarily Unavailable(일시적으로 서비스를 이용할 수 없음): 서비스를 일시적으로 사용할 수 없을 때 사용된다. 주로 웹서버 등이 과부하로 다운되었을 때 볼 수 있다.
504 Gateway Timeout(게이트웨이 시간초과): 게이트웨이가 연결된 서버로부터 응답을 받을 수 없었을 때 사용된다.
505 HTTP Version Not Supported(지원되지 않는 HTTP 버전): HTTP 버전을 서버가 처리할 수 없다. 브라우저는 서버가 처리 가능한 HTTP 버전을 자동으로 선택하므로, 왠만해서는 볼수 없는 오류이다.
506 Variant Also Negotiates: 서버 내부 구성(값)에 오류가 있어 반환되는 값에 컨텐츠 협상이 순환 참조로 이루어져 있다는걸 알려주는 코드.
507 Insufficient Storage: 서버 내부 구성(값)에 오류가 있어 선택된 가변 리소스는 투명한 콘텐츠 협상에 참여하도록 구성되므로 협상 과정에서 적절한 끝점이 아님을 알려주는 코드. WebDAV 전용.
508 Loop Detected: 서버가 요청을 처리하는 동안 무한 루프를 발견하였을 때 뜨는 응답코드. WebDAV 전용.
510 Not Extended(확장되지 않았음): 서버가 요청을 처리할때 요청에 대한 추가 확장이 필요한경우 뜨는 응답코드.
511 Network Authentication Required(네트워트 인증 필요): 사용자가 네트워크 엑세스 권한이 필요한 경우 뜨는 응답코드. 보통 네트워크에 엑세스할 때 로그인이 필요한 경우 주로 뜬다.

# HTTPS
HTTP 에 암호화와 인증, 그리고 완전성 보호를 더한 HTTPS

HTTPS는 SSL 의 껍질을 덮어쓴 HTTP 라고 할 수 있다. 즉, HTTPS 는 새로운 애플리케이션 계층의 프로토콜이 아니라는 것이다. HTTP 통신하는 소켓 부분을 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 프로토콜로 대체하는 것 뿐이다. HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 SSL 과 통신하고 SSL 이 TCP 와 통신 하게 된다. SSL 을 사용한 HTTPS 는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.

HTTPS 의 SSL 에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다. 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다.

모든 웹 페이지에서 HTTPS를 사용해도 될까?
평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구한다. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어들게 된다.

하지만 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작한다. 따라서 웹은 과거의 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용하는 방식에서 현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있다.