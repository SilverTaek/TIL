```
*필수적으로 알아야하는 면접 CS 지식*

1. 객체지향프로그래밍이란 무엇인가?
- 객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.
- 장점
코드 재사용이 용이 : 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음.
유지보수가 쉬움 : 절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨.
대형 프로젝트에 적합 : 클래스 단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러 회사에서 개발이 필요할 시 업무 분담하기 쉽다.

- 단점 
처리속도가 상대적으로 느림
객체가 많으면 용량이 커질 수 있음
설계시 많은 시간과 노력이 필요

객체지향 4대 특성
- 추상화 : 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다.
- 캡슐화 : 코드를 재수정 없이 재활용하는 것.
- 상속 : 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다.
- 다형성 : 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것이다.

객체 지향 설계 5원칙
- 단일 책임 원칙(SRP) : 하나의 클래스는 하나의 책임만 가져야한다.
- 개방 폐쇄 원칙(OCP) : 확장에 열려있고, 변경에 닫혀있다.
- 리스코프 치환 원칙(LSP) : 객체는 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야 한다,
- 인터페이스 분리 원칙(ISP) : 범용 인터페이스 하나보다는 특정 클라이언트를 위한 여러 개의 인터페이스 분리가 더 좋다고 한다.
- 의존관계 역전 원칙(DIP) : 구체화가 아니라 추상화에 의존해야 한다. 즉 구현 클래스(구현체)가 아니라 인터페이스(역할)에 의존

2. Java
- 자바의 장점
    - 간결하면서도 강력한 객체지향 언어이다.
    - 개방형 구조로 여러 기술과 융합이 가능하다.
    - 플랫폼에 독립적이므로, 여러 운영체제나 하드웨어에서도 동일하게 실행한다.
    - 많은 오픈소스 프레임워크로 생산성을 증가하고 유지보수 비용을 절감할 수 있다.

- 자바의 단점
    - 처리 속도가 중요한 애플리케이션에서는 적합하지 않다.
    - GUI 요소가 많은 MS 윈도 응용 프로그램 개발에는 적합하지 않다.
    - 하드웨어에 연결하여 제어할 수 없기 때문에(가상 머신 이용) 직접 하드웨어를 정밀하게 조정해야 하는 프로그램 개발에는 적합하지 않다.

- 자바 프로그램 개발 절차
    - 자바 프로그램 개발은 자바 소스 코드(.java)작성 -> 자바 컴파일러 -> 자바 바이트코드(.class, 컴파일) -> 자바 가상 머신(JVM) -> 운영체제, 하드웨어 -> 실행의 단계
    - 바이트코드는 운영체제에 상관없이 가상 머신에서 사용하는 중간 코드이다.

3. 절차 지향 프로그래밍 vs 객체 지향 프로그래밍
    - 절차적 프로그래밍 장점
        - 객체나 클래스를 만들 필요 없이 바로 프로그램을 코딩할 수 있다.
        - 필요한 기능을 함수로 만들어 두기 때문에 같은 코드를 복사하지 않고 호출하여 사용할 수 있다.
        - 프로그램의 흐름을 쉽게 추적할 수 있다.
    - 절차적 프로그래밍 단점
        - 각 코드가 매우 유기성이 높기 때문에 수정하기가 힘들다.
        - 프로그램 전체에서 코드를 재사용 할 수가 없어 프로젝트 개발 비용과 시간이 늘어날 수 있다.
        - 디버그가 어렵다.
    - 객체지향 프로그래밍 장점
        - 모듈화, 캡슐화로 인해 유지보수에 용이하다.
        - 객체지향적이기 때문에 현실 세계와 유사성에 의해 코드를 이해하기 쉽게 만든다.
        - 객체는 그 자체가 하나의 프로그램이기 때문에 다른 프로그램에서 재사용이 가능하다.
    - 객체지향 프로그래밍 단점
        - 대부분의 객체 지향 프로그램은 속도가 상대적으로 느려지고 많은 양의 메모리를 사용하는 경향이 있다.
        - 현실 세계와 유사성에 의해 코드를 이해하기 쉽게 만드는 만큼 설계 과정에 시간이 많이 투자된다.

4. 묵시적 형 변환 vs 명시적 형 변환
    - 묵시적 형 변환 : 자바에서 묵시적 형 변환이란 자동으로 형 변환 해주는 경우를 의미한다.,
    - 명시적 형 변환 : 데이터 앞에 변환할 타입으로 명시해주는 경우를 의미한다.(주로 큰 데이터 타입을 작은 데이터 타입으로 변환할 때 사용되며, 데이터 손실의 가능성이 있어 명시적으로 형 변환을 해주지 않을 경우 에러가 발생한다.)

5. Java에서의 Final
    - 변수나 메서드 또는 클래스가 '변경 불가능'하도록 만든다.
    - 클래스 이름 앞에 사용되면 클래스를 상속받을 수 없음을 지정한다.
    - 매서드 앞에 final 속성이 붙으면 이 메서드는 더 이상 오버라이딩 할 수 없음을 지정한다.
    - 필드 멤버에 final 키워드를 덧붙여 상수를 정의한다.

6. Java에서의 커넥션 풀
    - 웹 컨테이너(WAS)가 실행되면서 DB와 미리 connection(연결)을 해놓은 객체들을 pool에 저장 해두었다가 클라이언트 요청이 오면 connection을 빌려주고, 처리가 끝나면 다시 connection을 반납받아 pool에 저장하는 방식을 말합니다.

7. 예외와 에러 차이(https://toneyparky.tistory.com/40)
    - 에러는 시스템이 종료되어야 할 수준의 상황과 같이 수습할 수 없는 심각한 문제를 의미합니다. 개발자가 미리 예측하여 방지할 수 없습니다.
    - 예외는 개발자가 구현한 로직에서 발생한 실수나 사용자의 영향에 의해 발생합니다. 에러와 달리 개발자가 미리 예측하여 방지할 수 있기에 상황에 맞는 예외처리를 해야합니다.
    
8. 메모리 구조
    - 자바(JVM)의 메모리 영역은 heap, stack, static이 보통이지만 힙 메모리, 비 힙메모리, 기타의 세 가지로 나누어 설명한다.

    - 힙 영역 : 모든 자바 클래스의 인스턴스(instance)와 배열(array)이 할당되는 곳으로, 런타인 데이터를 저장하는 영역이다.
    힙 영역은 JVM이 시작될 때 생성되어 애플리케이션이 실행되는 동안 크기가 커졌다 작아졌다 한다. 힙 영역의 크기는 -Xms VM option으로 지정된다고 한다.
    힙 영역의 크기는 가비지 컬렉션의 전략에 따라 고정된 크기일 수도 있고, 유동적으로 변경될 수도 있다. 힙 영역의 최대 크기는 -Xms option으로 설정 되는데, 디폴트로 설정된 힙 영역의 크기는 64MB이다.

    - 비 힙 영역 : 힙 영역과 마찬가지로 JVM이 시작할 때 생성된다. 이 영역에는 런타임 상수 풀, 필드 및 메소드 데이터와 같은 클래스 별 구조와 메소드 및 생성자에 대한 코드뿐만 아니라 내부 문자열이 저장된다. 디폴트로 저장된 Non-Heap 영역의 크기는 64MB이며, 이는 XX:MaxPermSize VM option을 통해 변경될 수 있다.

    다른 메모리 영역 : JVM 자체의 코드와 JVM의 내부 구조, 로드된 프로파일어 에이전트 코드와 데이터 등을 저장하기 위해 사용된다.

9. 가상 함수
    - 인스턴스의 메서드가 호출되는 기술을 가상 메서드라고 합니다.

10. 스레드 vs 프로세스
    - 프로세스 : 실행되고 있는 컴퓨터 프로그램
    - 스레드 : 스레드는 프로세스의 코드에 정의된 절차에 따라 실행되는 특정한 수행 경로이다.
    - 차이 : 프로세스는 메모리에 올라갈 때 운영체제로부터 시스템 자원을 할당받는데 프로세스 마다 독립된 메모리 영역을 Code / Data / Stack / Heap의 형식으로 할당해 줍니다. 각각 독립된 메모리 영역을 할당해주기 때문에 프로세스끼리는 변수나 자료에 접근할 수 없습니다. 반면에 스레드는 메모리를 서로 공유할 수 있으며 각각의 스레드는 별도의 스택을 가지고 있지만 힙 메모리는 서로 읽고 쓸 수 있게 됩니다.

11. 클래스 vs 인스턴스
    - 클래스 : 일종의 설계도로써 휴대폰의 특성과 기능들을 정의해놓은 것
    - 인스턴스 : 실제로 메모리에 할당된 상태며 클래스를 통해 객체가 구현된 구체적인 실체

12. 오버로딩 vs 오버라이딩
    - 오버로딩 : 자바의 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있다.
    (메소드의 이름이 같고, 매개변수의 개수나 타입이 달라야 함.) ex) println
    - 오버라이딩 : 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것
    (자식 클래스에서는 오버라이딩하고자 하는 메소드의 이름, 매개변수, 리턴 값이 모두 같아야 한다.)
    (자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다.)
    (예외는 부모 클래스의 메소드 보다 많이 선언할 수 없다.)
    (static 메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다.)

13. Java Collection
    - 데이터의 집합, 그룹을 의미하며 Collection 인터페이스는 List, Set Queue로 크게 3가지 상위 인터페이스로 분류할 수 있습니다. 추가적으로 Map의 경우는 Collection 인터페이스를 상속받고 있지 않지만 Collection으로 분류됩니다.
(https://gangnam-americano.tistory.com/41)

14. Spring 사용하는 이유와 장점

15. Spring IOC/DI

    - DI : 스프링이 다른 프레임워크와 차별화되어 제공하는 의존 관계 주입 기능으로, 객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식, 모듈 간의 결합도가 낮아지고 유연성이 높아짐
    - IOC(Inversion of Control) : 제어의 역전이란 메소드나 객체의 호출작업을 개발자가 직접하는 것이 아니라 외부에서 결정되는 것을 의미한다.
    객체의 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성할 수 있게 하여 가독성 및 코드 중복, 유지 보수를 편하게 할 수 있게 한다.

16. Spring AOP
    - Aspect Oriented Programming 측면/양상 지향적인 프로그래밍 : 
    관점 지향 프로그래밍이라고 불린다. 관점 지향은 쉽게 말해 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다.

    프록시 패턴이라는 디자인 패턴을 사용하여 AOP 효과를 낸다. 프록시 패턴을 사용하면 어떤 기능을 추가하려 할 때 기존 코드를 변경하지 않고 기능을 추가할 수 있다.
    어떤 클래스가 Spring AOP의 대상이라면 그 기존 클래스의 빈이 만들어질때 Spring AOP가 프록시(기능이 추가된 클래스)를 자동으로 만들고 원본 클래스 대신 프록시를 빈으로 등록한다.
    그리고 원본 클래스가 사용되는 지점에서 프록시를 대신 사용한다.

17. Spring PSA
    - 환경의 변화와 관계없이 일관된 방식의 기술 접근 환경을 제공하려는 추상화 구조

18. Spring POJO(Plain Old Java Object)
EJB 등에서 사용되는 Java Bean 이 아닌 Getter 와 Setter 로 구성된 가장 순수한 형태의 기본 클래스를 POJO라 하며, 이는 Spring에서 고안된 철학의 핵심적인 부분을 구성하는 요소로 사용된다
진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다.
19. web.xml

20. CI/CD?
    - 개발 단계를 자동화하여 애플리케이션을 보다 짧은 주기로 통합, 배포 하는 방법입니다.
    - CI는 개발자간 변경사항의 충돌을 방지해주고 CD는 개발자의 변경사항을 고객이 사용가능한 환경까지 자동으로 릴리스 하는 것을 의미합니다.
21. Jenkins
    - 빌드를 자동화 해주는 툴이다. Ec2 security group의 인바운드 규칙에 젠킨스 포트를 추가해줘야 한다.
22. Docker
    - 소프트웨어를 컨테이너로 패키징하는 소프트웨어 플랫폼이다. 환경에 구애받지 않고 애플리케이션을 빠르게 배포 또는 확장할 수 있습니다.
Docker vs VM : 버츄얼머신은 가상화된 하드웨어에 os가 올라가지만 도커(or 컨테이너)는 os 부분을 가상화해서 커널을 host와 공유한다. -> 커널을 공유하기 때문에 용량이 적고 input과 output을 쉽게 처리할 수 있기 때문에 빠르다. 

23. Monolithic

24. MSA
    - 스스로 동작하고 독립적으로 배포가능한 서비스이다. 하나의 큰 어플리케이션을 여러 개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍쳐이다. 클라우드 사용에 적합하고 요구사항을 신속하게 반영하여 빠르게 배포할 수 있으며 부분적 장애에 대한 대처가 쉽다. 또한 신기술의 적용이 유연하다
25. 동기 vs 비동기

26. Mybatis vs JPA

27. Nginx
    - 비동기 ,event driven 방식이기 때문에 수평적 확장성이 높다
28. Redis

29. AWS

30. Serverless

31. 추천 서비스 알고리즘

32. 정규화 / 반정규화

33. DB 튜닝 속도 개선 방법

34. 서브쿼리

35. delete vs truncate

36. DB 힌트

37. Primary Key vs Foreign Key

38. 화이트 박스 , 블랙 박스 테스트

39. 개발 방법론 애자일?
    - 워터폴은 정해진 단계에 따라 순차적으로 진행하는 절차적 프로그래밍 기법이고 애자일은 연속된 단게로 개발하는 방법 대신 스프린트라는 단계로 이루어져 스프린트마다 개발 과정이나 요구사항을 필요에 따라 수정하며 진행하는 방법론입니다.
워터폴은 크리티컬한 결함이 후반 단계에서 발생될 경우 매우 치명적이지만 애자일은 스프린트마다 나오는 결과물을 통해 수정된 요구사항과 문제점을 빠르게 파악할 수 있습니다.

40. 기능과 비기능 차이

41. 빅데이터 3요소
    - Volume
    - Velocity
    - Variety
42. Json vs XML
    - Json : 브라우저 통신을 위한 속성-값 또는 키-값 쌍으로 이루어진 데이터 포맷
    - XML : 마크업 언어이다
43. 대칭키 vs 비대칭키
    - 대칭키 암호화 방식 : 암복호화에 사용하는 키가 동일한 암호화 방식을 말한다,
    - 비대칭키 암호화 방식 : 대칭키의 키교환 문제를 해결하기 위해 등장한 것, 모든 사람이 접근 가능한 키
44. 콜바이밸류 vs 콜바이 레퍼런스
    
45. 관계형디비 vs nosql

46. git stash

47. git rebase

48. git branch 전략

49. Java String / String buffer

50. join에 대해서 설명

51. 추상클래스 / 인터페이스
    - 추상클래스 :  추상 메서드를 선언하여 상속을 통해서 자식 클래스에서 완성하도록 유도하는 클래스입니다. 상속을 위한 클래스이기 때문에 따로 객체를 생성할 수는 없습니다.
    - 인터페이스 : 기본 설계도이며 추상클래스처럼 다른 클래스를 작성하는데 도움을 주는 목적으로 작성하고 클래스와 다르게 다중상속이 가능합니다.
    - 차이점 : 사용 용도, 만약 모든 클래스가 인터페이스를 사용해서 기본 틀을 구성한다면 공통으로 필요한 기능들도 모든 클래스에서 오버라이딩 하여 재정의 해야하는 번거로움이 있습니다.
    - 추상클래스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 같은 조상클래스를 상속하는데 기능까지 완변히 똑같은 기능이 필요한 경우
    - 인터페이스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 다른 조상클래스를 상속하는데 같은 기능이 필요할 경우 인터페이스 사용
```

## 1. GC에 대해 설명하시오
* 메모리를 안쓰고 있다라는것을 판단하는 기준은 객체가 더 이상 참조되지 않을 때 GC가 발생한다.
* A a = new A(); 가정하에 더 이상 a를 참조하는곳이 없으면 a는 Heap 영역으로 이동한다.
* Heap영역은 다시 Young Generation 영역과 Old Generation 영역으로 나뉘는데 Young 영역은 Eden 영역과 Survivor 0 / Survivor 1 영역으로 나뉜다. 
* Eden 영역에 쌓인 객체는 Survivor 0와 Survivor 1 영역에 번갈아가며 쌓이며 객체의 age가 증가하고 한계점에 다다르면 Old Generation으로 이동한다.
* Old Generation이 한계에 다다르면 Major GC가 발생한다.
* 객체의 크기가 큰 경우 Eden 영역에서 Survivor 영역으로 이동하지않고 바로 Old Generation영역으로 이동할 수 있다.

## 2. Static을 잘못쓰면 메로리릭이 발생할 수 있는데 어떨 때 발생할 수 있는가?(JAVA는 GC로 인해 메모리릭이 발생할 가능성이 낮은데 메모리릭이 발생할 수 있는 패턴에 대해 설명해보시오)

메모리릭은 개발자가 메모리 할당을 해놓고 할당을 해제안했을 때 발생하는 문제
static으로 자료구조를 선언하면 메모리가 제대로 할당해제가 안되고 찌꺼기가 쌓여 결국에는 메모리릭이 발생 할 수 있다.

## 3. 회원가입 할 때 HashMap을 static으로 만들고 public으로 선언했을 때 어떻게 될것인지?

다른 개발자가 유지보수의 관점에서 의도하지않게 회원가입을 하는 상황이 발생할 수 있다.
이러한 부분도 메모리릭이 발생할 수 있는 포인트이다.

## 4. 1KB는 몇 바이트일까?
1024 Byte

## 5. 캐싱에 대한 개념
쿼리를 실행할 때마다 비용이 증가하는데 반복되는 쿼리를 줄여 비용을 낮추기위해 메모리에 저장하여 응답속도를 개선하는 것

## 6. 메모리의 단점
용량이 적은데 가격이 비싸다.

결론적으로 서버 캐시 비용을 낮춰서 회사에 운영 비용을 낮춰 연봉 인상협상에 유리하게 작용할 수 있음

## 7. 톰캣 스레드풀, DB 커넥션풀 병목이 많이 일어나는데 자세히 알아보기
* Tomcat Thread pool : WAS의 종류중 하나인 Tomcat은 기본적으로 접근하는 request들에 대해 Thread를 할당하여 작업을 수행하도록 해준다.
Thread pool을 사용하여 쓰레드를 재사용 할 수 있게 해주고 max-thread, connection timeout 등의 설정을 사용자가 직접 설정 해 줄 수 있다.

```
Tomcat8 default 
maxThread = 200(쓰레드풀 최대 쓰레드 갯수)
minSpareThreads = 25(쓰레드풀 초기 쓰레드 갯수)
```

* DB Connection pool : DB Connection 정보를 캐시에 저장/관리하여 애플리케이션 단에서 DB Connection 정보가 필요할 때마다 Connection pool에서 연결 정보를 가지고 와 사용하도록 하는 것이다. connection pool에서 Connection 정보를 관리하기 때문에 DB에 연결하기 위한 연결 정보 생성 시간이 없어 DB Connection을 위한 시간이 월등히 줄어든다.

## 8. 쓰레드는 왜 사용해야 할까?(동시에 처리했을 때 빨라지는 이유)

쓰레드를 사용하면 동시에 여러개의 코드를 수행할 수 있으므로 동시에 엄청난 양이 들어오는 채팅 서비스나 공장의 경우에는 하나씩 처리하면 엄청난 시간이 걸리기 때문에 쓰레드를 사용하여 많은 양도 한번에 처리할 수 있다

다만 쓰레드를 사용 시 주의할 점이자 단점은 쓰레드로 한번에 많은 코드들을 수행할수록 컴퓨터에 부하가 심해지며 쓰레드 수행 도중 내게 필요한 자원을 남이 가지고 있고 남은 남에게 필요한 자원을 내가 가지고 있어서 서로 무한정 대기하는 교착상태(Deadlock) 문제가 있다.

## 9. I/O가 일어날 때 쓰레드가 어떻게 될까?

일반적으로 블로킹된다.

## 10. 스레드 개수를 늘리면 ContextSwitching이 늘어나는데 스레드 갯수를 줄이면서 처리량을 늘릴 수 있는 방법이 있는가?

## 11. NIO가 무엇인지?

NIO의 가장 큰 특징으로 비동기 / non-blocking 방식을 지원한다.
Non-Blocking Model 이란 I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식이다.

비동기(Asynchronous) 이란 I/O 작업이 진행되는 동안 유저 프로세스는 관심이 없다. 그저 자신의 일을 하다가 이벤트 핸들러에 의해 알림(notify)이 오면 처리하는 방식이다.

또한, NIO는 (버퍼, 채널, 셀렉터)를 이용해 성능이 좋다.

버퍼 - 커널에 의해 관리되는 시스템 메모리를 직접 사용할 수 있는 Buffer 클래스

채널 - 읽기, 쓰기 하나씩 쓸 수 있는 단반 향식 스트림, 채널은 읽기 쓸기 둘 다 가능한 양방향 입출력 클래스이다. 네이티브 IO, Scatter/Gatter 구현으로 효율적 IO처리 ( 시스템 콜 줄이기, 모아서 처리)

셀렉터 - 네트워크 프로그래밍 효율을 높인다. 클라이언트 하나당 스레드 하나를 생성해서 처리하기에 스레드가 많이 생성 도리 수록 급격한 성능 저하를 가졌던 단점을 개선하는 Reactor패턴의 구현체

## 12. WebFlux가 무엇인가?

우리가 보통 사용하던 Spring MVC + RDBMS 패턴은 Blocking IO 방식이다. Blocking IO 방식이라는 것은 요청을 처리하기 전까지는 다른 작업을 수행할 수 없는 상태라는 것을 말한다. 동시에 여러 요청을 처리하기 위해서는 Thread 수를 늘려서 하는 방법이 존재하기는 하지만 이도 오버헤드가 발생한다. 이를 개선하기 위해 나온 기술이 Non-Blocking IO 방식인 Spring WebFlux 이다. Spring WebFlux 는 동시에 처리되어야 할 많은 요청에 대해 효율적으로 처리해줄 수 있다. 


## 13. Java8에서 새로나온것은?

## 14. Spring5에서 새로나온것은?

WebFlux(Reactive Programming Model)

## 15. TCP UDP의 차이

손실되도 되는 데이터 -> UDP
카톡 -> TCP (성능이 느림) -> Point) 3-hand-shaking

## 16. Serialization이 뭘까요?

## 17. 어떨때 인터페이스를 써야하고 어떨때 추상클래스를 써야할까요?
### 공통된 기능 사용 여부

만약 모든 클래스가 인터페이스를 사용해서 기본 틀을 구성한다면 공통으로 필요한 기능들도 모든 클래스에서 오버라이딩 하여 재정의 해야하는 번거로움이 있습니다. 이렇게 공통된 기능이 필요하다면 추상클래스를 이용해서 일반 메서드를 작성하여 자식 클래스에서 사용할 수 있도록 하면 된다. 어!? 그러면 그냥 추상클래스만 사용하면 되는 거 아닌가요? 위에서 얘기 했듯이 자바는 하나의 클래스만 상속이 가능합니다. 만약 각각 다른 추상클래스를 상속하는데 공통된 기능이 필요하다면? 해당 기능을 인터페이스로 작성해서 구현하는게 편하겠죠?


## 18. Optional은 어떨때 왜쓰는걸까요?

## 19. Push 메세지를 날리는 서버를 만들 때 성능을 높일 수 있는 방법은 어떤게 있을까요?

push 메세지를 최대한 많이 보내야하는데 밑도 끝도없이 막 던질 수 있는 방법은 무엇이 있는지 

던졌을 때 요청을 보냈을 때 응답이 올때까지 기다리는 부분을 해결하기 위해서 NonBlokingI/O를 사용해야 합니다. 따라서 짧은 시간안에 확 던질 수 있다.

NonBlokingI/O도 요청이 많이 발생했을 때 메모리에 저장해야하는데 이럴 때 OutOfMemory가 발생할 수 있다.

이를 해결하기위해 WebSocket을 사용한다. 단방향 즉, 응답을 받을 필요가 없다. TCP 특징을 이용해서 상대방에게 잘전송이됐는지만 중요하다.

## 20. Session은 어디에 저장이 될지?

메모리에 저장
Session은 임시성 데이터, 클라이언트가 최초로 접속했을 때 세션이 생성된다.
SessionId를 통해 사용자를 식별하고 Id가 없으면 최초 접속했다고 판단한다. 또한 쿠키에 담아서 온다.
Header에 담아서 오는데 set cookie header이다.

## 21. CPU 사용량이 높아졌을 때 어떻게 해야할지?
ScaleOut , ScaleUp 각각의 특징 살펴보기.

## 22. Auth 살펴보기

## 23. Filter라는것은 개발할 때 어떻게 사용할 수 있을지?

## 24. 인터셉터와 필터의 차이 (실행되는 시점 제외)

## 25. 커넥션을 만드는게 왜느릴지?

JDBC를 개발할 때 커넥션을 열고 닫고하는 반복적인 부분이 발생하는데 TCP에서 커넥션을 맺을 때 3-hand-shaking, 닫을 때는 4-hand-shaking이 반복적으로 발생하기 때문에 TCP는 맺고 끝는게 매우 느려서 풀을 만들어서 돌려서 사용한다.

## 26. MVC?

MVC 는 Model, View, Controller의 약자 입니다. 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴입니다.

## 27. DispatcherServlet?

## 28. 배민 시험 과제(서블릿 구조 만들어오기, DispatcherServlet부터 껍데기부터 톰캣자체를 혼자서 만들어 오기 그래서 웹으로 접속했을 때 눈에 보여야하고 Http가 출력)

## 29. 서버에서 SessionId를 생성했을 때 클라이언트의 쿠키에 자동으로 세팅되는데 어떤거 때문에 ?

서버에서 세션을 만들어주고 응답의 헤더에 SetCookie를 만들어준다.

## 30. 서버가 Stateless하다라는것은 무슨 말일까?

서버에 어떤 값을 저장하지 않는것 -> 장점은 어떤게 있을까?
동일한 값을 공유하기위해 부하가 생긴다. -> 서버에 값을 저장하지않으면 이러한 부담을 줄어들어서 서버의 성능이 빨라진다.

## 31. sticky Session, Session Clustering

### Sticky Session
직역을 하면 고정된 세션이라는 뜻으로 A 유저의 모든 서비스 활동을 A Server에서 고정되어 사용하는 방법입니다.
* Sticky Session 장점
특정 세션의 요청을 처음 처리한 서버로만 보내기 때문에 정합성 이슈를 해결할 수 있습니다.
* Sticky Session 단점
특정서버(A Server)에만 트래픽이 몰릴 수 있다는 단점이 있습니다.
A Server가 다운되면 저장된 Session이 유실될 수 있습니다.

### Session Clustring
여러 대의 컴퓨터들이 하나의 시스템처럼 동작하도록 만드는 것을 클러스트링이라고 합니다.

A 클라이언트의 세션정보를 복사하여 A/B/C Server에 저장합니다.

* Session Clustring 장점
서버 한대가 시스템장애가 발생해도 다른 서버에서 그 역할을 대신 수행할 수 있습니다.
위 그림처럼 A 클라이언트가 어떤 서버에 접속하더라도 정합성 이슈가 해결됩니다.
* Session Clustring 단점
모든 서버가 동일한 세션 객체를 가져야 하기 때문에 많은 메모리가 필요합니다.
서버 증설에 따라 모든 서버에 세션을 저장해야하기 때문에 트래픽이 증가할 수 있습니다.
## 32. 캐싱관련 LRU, LFU

## 33. 디자인 패턴의 정의
oop를 잘지키기위한 패턴, solid 5원칙같이 개발자들이 잘지키려고한 패턴들을 모아서 만든게 디자인 패턴

## 34. 단일책임원칙을 적용했을 때 프로젝트에 어떻게 좋아질지?
재사용성이 높아짐

## 35. 개방폐쇄원칙과 다형성의 연관성은?
인터페이스 -> 변경에 닫혀있음, 확장에 열려있음

## 36. Spring Boot가 정말 편한데 설정값만 설정해주면 디비 연결해주고 이러한 것들은 Spring의 핵심가치 중 어떤것의 혜택일까요?
IOC 주입에 대한 개념

## 37. IOC와 SpringBoot와 엮어보면은? IOC란?
그 전에 Spring이 어떻게 하고 있기때문에(전제조건)어떤?
답변 : Spring은 객체 라이프 사이클을 관리해줍니다.

## 38. 개방폐쇄원칙은 어떤게 좋아지는걸까?
레고를 갈아 끼우듯이 기능 단위로 만들어서 바꿔 끼울 수 있어서 개발 생산성이 올라간다.

Mysql에 스토리지엔진을 쉽게 갈아낄 수 있는데 마찬가지로 개방폐쇄의 원칙에 해당됨
PG사 중 이니시스, 나이스페이를 쉽게 갈아낄 수 있게 할 수도있음
그래서 나온게 아이포트 여러 PG사를 API로 단일화 => 개방폐쇄원칙 

## 39. 싱글톤패턴을 구현할 때 주의해야할점이 무엇이 있을까?

```
public class SingleTon {
    
    private static SingleTon INSTANCE = null;

    public static SingleTon getInstance() {

        if(INSTANCE == null) {
            INSTANCE = new SingleTon();
        }

        return INSTANCE;
    }
}
```

위 코드는 객체를 단일 생성한다는것을 보장할까? => 보장은 한다.
단, 멀티스레드에서 해당 메소드를 호출하면 어떻게 될까? -> ex) 스레드 3개가 동시에 접근하면 보장이 안된다.

```
public class SingleTon {
    
    private static SingleTon INSTANCE = null;

    public synchronized static SingleTon getInstance() {

        if(INSTANCE == null) {
            INSTANCE = new SingleTon();
        }

        return INSTANCE;
    }
}
```
위 코드는 객체를 가져올때마다 줄을 세운다. 많은 사용자들이 발생하면 성능저하발생

```
public class SingleTon {
    
    private static SingleTon INSTANCE = null;

    public static SingleTon getInstance() {

        if(INSTANCE == null) {
           synchronized {
               if (INSTANCE = null) {
            INSTANCE = new SingleTon();
               }
           }
        }

        return INSTANCE;
    }
}
```
위 코드는 스레드 세이프할까? => 락이 안걸려 성능문제를 해결한것같은데 하나만 생성하는게 보장이 된것일까?

더블체크드락 패턴 -> 한동안 많이 썼던 패턴이지만 다른사람이 의문을 제기해서 요즘엔 사용하지 않음

## 40. 싱글톤 구현 패턴 찾아보기
- 싱글톤을 구현할 때 주의할점
ex) Thread Safe 하지 않을 때, 객체가 한개만 생성된다라는것을 보장할 수 없습니다. -> 어떤거때문에 하나만 생성되는것을 보장하지 않나요 -> 그렇다면 싱글톤을 구현할 수 있는게 머머 있을까요 각각의 장단점은?

## 41. @Autowired / @resource의 차이

@resource => 이름 기준, @Autowired => 타입 기준으로 주입한다. 외에 차이점 찾아보기
어떨때 쓰면 좋을까?
feat) 어떻게 우리가 회사의 돈을 날려먹을 수 있을까?
Autowired를 사용하면 회사의 돈을 날려먹을 수 있다.

@Qulifier
@Primary

명시적(다른 개발자들이 코드를 보고 바로 알 수 있는것) vs 암묵적
ex) 명시적이지 않은경우, RDB 의존성 주입이 잘못되면 오류를 내지만 Nosql같은 경우는 에러가 안나와서 실제 1을 insert했는데 다른것을 insert할 수 있어서 위험하다.

## 42. @Transactional 격리레벨, 프로파게이션 알아보기

### propagation(전파)
* REQUIRED : 트랜잭션 필요. 진행 중이라면 해당 트랜잭션 사용. 없으면 생성
* MANDATORY : 트랜잭션 필요. 트랜잭션 존재하지 않으면 익셉션 발생
* NEVER : 트랜잭션이 불필요. 진행중인 트랜잭션 존재하면 익셉션 발생
* NESTED : 기존 트랜잭션 존재하면 중첩된 트랜잭션에서 메서드 실행

### isolation level(격리 레발)
* DEFAULT : 기본 설정
* READ_UNCOMMITED : 다른 트랜잭션에서 커밋하지 않는 데이터 읽기 가능
* READ_COMMITED : 다른 트랜잭션에 의해 커밋된 데이터 읽기 가능
* REPEATABLE_READ : 처음 읽은 데이터와 두 번째 읽은 데이터가 동일
* SERIALIZABLE : 동일한 데이터에 대해 두 개 이상의 트랜잭션 수행 불가

## 43. POJO가 왜 Spring에서 중요한지?

메소드 안에 보면 Spring에 의존적인 코드가 하나도 안들어있죠
결국엔 우리 코드안에는 비지니스만 남아있다는 말이다.
부가적인 스프링에 종속적인건 다빠져있죠 AOP 어노테이션으로
즉, 우리의 코드에는 비지니스만 남아있을 수 있어서 POJO가 중요하다
그렇다면 어노테이션은 Spring에 종속적인것이냐? 사실 부가기능이기때문에
다른 프레임워크를 사용해도 트랜잭션같은건 해당 프레임워크에 맞게 갈아끼우면 된다.

## 44. Git flow를 들어본 적이 있는지?, 왜 써야하는지?
다른 사람한테 보여준다라는 측면보다 소스 코드 버전관리 측면에서 설명
버전 관리란 무엇인지?(vcs, version controller system)
버전 관리만 할거면 서버가 꼭 필요할까?

## 45. 하이버네이트 함부러 쓰면 쿼리가 여러개 나감, 나가는건 블로킹 I/O

## 46. 토비 스프링 같은 경우 바이트 코드를 갈아끼는부분까지 파고들자!

## 47. 트랜잭션 Isolation, propagation

## 48. 성능 튜닝은 아무나 할 수 있다.

클라우드에 올리고 성능 테스트를 하면서 CPU 사용량 100 프로까지 올려서 어느 부분에 병목이 있는데 확인한다
예를 들어 트랜잭션에 데드락 문제가 있을 수 있고, 커넥션 풀에 존재를 알고있으면 해당 부분 등등

jmx -> jvm 튜닝
top -> 서버 지표 뽑기 가능
iostat -> i/o뽑기

## 49. 네이버 파이낸셜 문제
최대한 자세하게, 얼마나 개발자답게 접근했는지 알려주세요(트레이드 오프)


