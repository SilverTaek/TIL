## 1. GC에 대해 설명하시오
* 메모리를 안쓰고 있다라는것을 판단하는 기준은 객체가 더 이상 참조되지 않을 때 GC가 발생한다.
* A a = new A(); 가정하에 더 이상 a를 참조하는곳이 없으면 a는 Heap 영역으로 이동한다.
* Heap영역은 다시 Young Generation 영역과 Old Generation 영역으로 나뉘는데 Young 영역은 Eden 영역과 Survivor 0 / Survivor 1 영역으로 나뉜다. 
* Eden 영역에 쌓인 객체는 Survivor 0와 Survivor 1 영역에 번갈아가며 쌓이며 객체의 age가 증가하고 한계점에 다다르면 Old Generation으로 이동한다.
* Old Generation이 한계에 다다르면 Major GC가 발생한다.
* 객체의 크기가 큰 경우 Eden 영역에서 Survivor 영역으로 이동하지않고 바로 Old Generation영역으로 이동할 수 있다.

## 2. Static을 잘못쓰면 메로리릭이 발생할 수 있는데 어떨 때 발생할 수 있는가?(JAVA는 GC로 인해 메모리릭이 발생할 가능성이 낮은데 메모리릭이 발생할 수 있는 패턴에 대해 설명해보시오)

메모리릭은 개발자가 메모리 할당을 해놓고 할당을 해제안했을 때 발생하는 문제
static으로 자료구조를 선언하면 메모리가 제대로 할당해제가 안되고 찌꺼기가 쌓여 결국에는 메모리릭이 발생 할 수 있다.

## 3. 회원가입 할 때 HashMap을 static으로 만들고 public으로 선언했을 때 어떻게 될것인지?

다른 개발자가 유지보수의 관점에서 의도하지않게 회원가입을 하는 상황이 발생할 수 있다.
이러한 부분도 메모리릭이 발생할 수 있는 포인트이다.

## 4. 1KB는 몇 바이트일까?
1024 Byte

## 5. 캐싱에 대한 개념
쿼리를 실행할 때마다 비용이 증가하는데 반복되는 쿼리를 줄여 비용을 낮추기위해 메모리에 저장하여 응답속도를 개선하는 것

## 6. 메모리의 단점
용량이 적은데 가격이 비싸다.

결론적으로 서버 캐시 비용을 낮춰서 회사에 운영 비용을 낮춰 연봉 인상협상에 유리하게 작용할 수 있음

## 7. 톰캣 스레드풀, DB 커넥션풀 병목이 많이 일어나는데 자세히 알아보기
* Tomcat Thread pool : WAS의 종류중 하나인 Tomcat은 기본적으로 접근하는 request들에 대해 Thread를 할당하여 작업을 수행하도록 해준다.
Thread pool을 사용하여 쓰레드를 재사용 할 수 있게 해주고 max-thread, connection timeout 등의 설정을 사용자가 직접 설정 해 줄 수 있다.

```
Tomcat8 default 
maxThread = 200(쓰레드풀 최대 쓰레드 갯수)
minSpareThreads = 25(쓰레드풀 초기 쓰레드 갯수)
```

* DB Connection pool : DB Connection 정보를 캐시에 저장/관리하여 애플리케이션 단에서 DB Connection 정보가 필요할 때마다 Connection pool에서 연결 정보를 가지고 와 사용하도록 하는 것이다. connection pool에서 Connection 정보를 관리하기 때문에 DB에 연결하기 위한 연결 정보 생성 시간이 없어 DB Connection을 위한 시간이 월등히 줄어든다.

## 8. 쓰레드는 왜 사용해야 할까?(동시에 처리했을 때 빨라지는 이유)

쓰레드를 사용하면 동시에 여러개의 코드를 수행할 수 있으므로 동시에 엄청난 양이 들어오는 채팅 서비스나 공장의 경우에는 하나씩 처리하면 엄청난 시간이 걸리기 때문에 쓰레드를 사용하여 많은 양도 한번에 처리할 수 있다

다만 쓰레드를 사용 시 주의할 점이자 단점은 쓰레드로 한번에 많은 코드들을 수행할수록 컴퓨터에 부하가 심해지며 쓰레드 수행 도중 내게 필요한 자원을 남이 가지고 있고 남은 남에게 필요한 자원을 내가 가지고 있어서 서로 무한정 대기하는 교착상태(Deadlock) 문제가 있다.

## 9. I/O가 일어날 때 쓰레드가 어떻게 될까?

일반적으로 블로킹된다.

## 10. 스레드 개수를 늘리면 ContextSwitching이 늘어나는데 스레드 갯수를 줄이면서 처리량을 늘릴 수 있는 방법이 있는가?

## 11. NIO가 무엇인지?

NIO의 가장 큰 특징으로 비동기 / non-blocking 방식을 지원한다.
Non-Blocking Model 이란 I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식이다.

비동기(Asynchronous) 이란 I/O 작업이 진행되는 동안 유저 프로세스는 관심이 없다. 그저 자신의 일을 하다가 이벤트 핸들러에 의해 알림(notify)이 오면 처리하는 방식이다.

또한, NIO는 (버퍼, 채널, 셀렉터)를 이용해 성능이 좋다.

버퍼 - 커널에 의해 관리되는 시스템 메모리를 직접 사용할 수 있는 Buffer 클래스

채널 - 읽기, 쓰기 하나씩 쓸 수 있는 단반 향식 스트림, 채널은 읽기 쓸기 둘 다 가능한 양방향 입출력 클래스이다. 네이티브 IO, Scatter/Gatter 구현으로 효율적 IO처리 ( 시스템 콜 줄이기, 모아서 처리)

셀렉터 - 네트워크 프로그래밍 효율을 높인다. 클라이언트 하나당 스레드 하나를 생성해서 처리하기에 스레드가 많이 생성 도리 수록 급격한 성능 저하를 가졌던 단점을 개선하는 Reactor패턴의 구현체

## 12. WebFlux가 무엇인가?

우리가 보통 사용하던 Spring MVC + RDBMS 패턴은 Blocking IO 방식이다. Blocking IO 방식이라는 것은 요청을 처리하기 전까지는 다른 작업을 수행할 수 없는 상태라는 것을 말한다. 동시에 여러 요청을 처리하기 위해서는 Thread 수를 늘려서 하는 방법이 존재하기는 하지만 이도 오버헤드가 발생한다. 이를 개선하기 위해 나온 기술이 Non-Blocking IO 방식인 Spring WebFlux 이다. Spring WebFlux 는 동시에 처리되어야 할 많은 요청에 대해 효율적으로 처리해줄 수 있다. 


## 13. Java8에서 새로나온것은?

## 14. Spring5에서 새로나온것은?

WebFlux(Reactive Programming Model)

## 15. TCP UDP의 차이

손실되도 되는 데이터 -> UDP
카톡 -> TCP (성능이 느림) -> Point) 3-hand-shaking

## 16. Serialization이 뭘까요?

## 17. 어떨때 인터페이스를 써야하고 어떨때 추상클래스를 써야할까요?
### 공통된 기능 사용 여부

만약 모든 클래스가 인터페이스를 사용해서 기본 틀을 구성한다면 공통으로 필요한 기능들도 모든 클래스에서 오버라이딩 하여 재정의 해야하는 번거로움이 있습니다. 이렇게 공통된 기능이 필요하다면 추상클래스를 이용해서 일반 메서드를 작성하여 자식 클래스에서 사용할 수 있도록 하면 된다. 어!? 그러면 그냥 추상클래스만 사용하면 되는 거 아닌가요? 위에서 얘기 했듯이 자바는 하나의 클래스만 상속이 가능합니다. 만약 각각 다른 추상클래스를 상속하는데 공통된 기능이 필요하다면? 해당 기능을 인터페이스로 작성해서 구현하는게 편하겠죠?


## 18. Optional은 어떨때 왜쓰는걸까요?

## 19. Push 메세지를 날리는 서버를 만들 때 성능을 높일 수 있는 방법은 어떤게 있을까요?

push 메세지를 최대한 많이 보내야하는데 밑도 끝도없이 막 던질 수 있는 방법은 무엇이 있는지 

던졌을 때 요청을 보냈을 때 응답이 올때까지 기다리는 부분을 해결하기 위해서 NonBlokingI/O를 사용해야 합니다. 따라서 짧은 시간안에 확 던질 수 있다.

NonBlokingI/O도 요청이 많이 발생했을 때 메모리에 저장해야하는데 이럴 때 OutOfMemory가 발생할 수 있다.

이를 해결하기위해 WebSocket을 사용한다. 단방향 즉, 응답을 받을 필요가 없다. TCP 특징을 이용해서 상대방에게 잘전송이됐는지만 중요하다.

## 20. Session은 어디에 저장이 될지?

메모리에 저장
Session은 임시성 데이터, 클라이언트가 최초로 접속했을 때 세션이 생성된다.
SessionId를 통해 사용자를 식별하고 Id가 없으면 최초 접속했다고 판단한다. 또한 쿠키에 담아서 온다.
Header에 담아서 오는데 set cookie header이다.

## 21. CPU 사용량이 높아졌을 때 어떻게 해야할지?
ScaleOut , ScaleUp 각각의 특징 살펴보기.

## 22. Auth 살펴보기

## 23. Filter라는것은 개발할 때 어떻게 사용할 수 있을지?

## 24. 인터셉터와 필터의 차이 (실행되는 시점 제외)

## 25. 커넥션을 만드는게 왜느릴지?

JDBC를 개발할 때 커넥션을 열고 닫고하는 반복적인 부분이 발생하는데 TCP에서 커넥션을 맺을 때 3-hand-shaking, 닫을 때는 4-hand-shaking이 반복적으로 발생하기 때문에 TCP는 맺고 끝는게 매우 느려서 풀을 만들어서 돌려서 사용한다.

## 26. MVC?

MVC 는 Model, View, Controller의 약자 입니다. 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴입니다.

## 27. DispatcherServlet?

## 28. 배민 시험 과제(서블릿 구조 만들어오기, DispatcherServlet부터 껍데기부터 톰캣자체를 혼자서 만들어 오기 그래서 웹으로 접속했을 때 눈에 보여야하고 Http가 출력)

## 29. 서버에서 SessionId를 생성했을 때 클라이언트의 쿠키에 자동으로 세팅되는데 어떤거 때문에 ?

서버에서 세션을 만들어주고 응답의 헤더에 SetCookie를 만들어준다.

## 30. 서버가 Stateless하다라는것은 무슨 말일까?

서버에 어떤 값을 저장하지 않는것 -> 장점은 어떤게 있을까?
동일한 값을 공유하기위해 부하가 생긴다. -> 서버에 값을 저장하지않으면 이러한 부담을 줄어들어서 서버의 성능이 빨라진다.

## 31. sticky Session, Session Clustering

### Sticky Session
직역을 하면 고정된 세션이라는 뜻으로 A 유저의 모든 서비스 활동을 A Server에서 고정되어 사용하는 방법입니다.
* Sticky Session 장점
특정 세션의 요청을 처음 처리한 서버로만 보내기 때문에 정합성 이슈를 해결할 수 있습니다.
* Sticky Session 단점
특정서버(A Server)에만 트래픽이 몰릴 수 있다는 단점이 있습니다.
A Server가 다운되면 저장된 Session이 유실될 수 있습니다.

### Session Clustring
여러 대의 컴퓨터들이 하나의 시스템처럼 동작하도록 만드는 것을 클러스트링이라고 합니다.

A 클라이언트의 세션정보를 복사하여 A/B/C Server에 저장합니다.

* Session Clustring 장점
서버 한대가 시스템장애가 발생해도 다른 서버에서 그 역할을 대신 수행할 수 있습니다.
위 그림처럼 A 클라이언트가 어떤 서버에 접속하더라도 정합성 이슈가 해결됩니다.
* Session Clustring 단점
모든 서버가 동일한 세션 객체를 가져야 하기 때문에 많은 메모리가 필요합니다.
서버 증설에 따라 모든 서버에 세션을 저장해야하기 때문에 트래픽이 증가할 수 있습니다.
## 32. 캐싱관련 LRU, LFU

## 33. 디자인 패턴의 정의
oop를 잘지키기위한 패턴, solid 5원칙같이 개발자들이 잘지키려고한 패턴들을 모아서 만든게 디자인 패턴

## 34. 단일책임원칙을 적용했을 때 프로젝트에 어떻게 좋아질지?
재사용성이 높아짐

## 35. 개방폐쇄원칙과 다형성의 연관성은?
인터페이스 -> 변경에 닫혀있음, 확장에 열려있음

## 36. Spring Boot가 정말 편한데 설정값만 설정해주면 디비 연결해주고 이러한 것들은 Spring의 핵심가치 중 어떤것의 혜택일까요?
IOC 주입에 대한 개념

## 37. IOC와 SpringBoot와 엮어보면은? IOC란?
그 전에 Spring이 어떻게 하고 있기때문에(전제조건)어떤?
답변 : Spring은 객체 라이프 사이클을 관리해줍니다.

## 38. 개방폐쇄원칙은 어떤게 좋아지는걸까?
레고를 갈아 끼우듯이 기능 단위로 만들어서 바꿔 끼울 수 있어서 개발 생산성이 올라간다.

Mysql에 스토리지엔진을 쉽게 갈아낄 수 있는데 마찬가지로 개방폐쇄의 원칙에 해당됨
PG사 중 이니시스, 나이스페이를 쉽게 갈아낄 수 있게 할 수도있음
그래서 나온게 아이포트 여러 PG사를 API로 단일화 => 개방폐쇄원칙 

## 39. 싱글톤패턴을 구현할 때 주의해야할점이 무엇이 있을까?

```
public class SingleTon {
    
    private static SingleTon INSTANCE = null;

    public static SingleTon getInstance() {

        if(INSTANCE == null) {
            INSTANCE = new SingleTon();
        }

        return INSTANCE;
    }
}
```

위 코드는 객체를 단일 생성한다는것을 보장할까? => 보장은 한다.
단, 멀티스레드에서 해당 메소드를 호출하면 어떻게 될까? -> ex) 스레드 3개가 동시에 접근하면 보장이 안된다.

```
public class SingleTon {
    
    private static SingleTon INSTANCE = null;

    public synchronized static SingleTon getInstance() {

        if(INSTANCE == null) {
            INSTANCE = new SingleTon();
        }

        return INSTANCE;
    }
}
```
위 코드는 객체를 가져올때마다 줄을 세운다. 많은 사용자들이 발생하면 성능저하발생

```
public class SingleTon {
    
    private static SingleTon INSTANCE = null;

    public static SingleTon getInstance() {

        if(INSTANCE == null) {
           synchronized {
               if (INSTANCE = null) {
            INSTANCE = new SingleTon();
               }
           }
        }

        return INSTANCE;
    }
}
```
위 코드는 스레드 세이프할까? => 락이 안걸려 성능문제를 해결한것같은데 하나만 생성하는게 보장이 된것일까?

더블체크드락 패턴 -> 한동안 많이 썼던 패턴이지만 다른사람이 의문을 제기해서 요즘엔 사용하지 않음

## 40. 싱글톤 구현 패턴 찾아보기
- 싱글톤을 구현할 때 주의할점
ex) Thread Safe 하지 않을 때, 객체가 한개만 생성된다라는것을 보장할 수 없습니다. -> 어떤거때문에 하나만 생성되는것을 보장하지 않나요 -> 그렇다면 싱글톤을 구현할 수 있는게 머머 있을까요 각각의 장단점은?

## 41. @Autowired / @resource의 차이

@resource => 이름 기준, @Autowired => 타입 기준으로 주입한다. 외에 차이점 찾아보기
어떨때 쓰면 좋을까?
feat) 어떻게 우리가 회사의 돈을 날려먹을 수 있을까?
Autowired를 사용하면 회사의 돈을 날려먹을 수 있다.

@Qulifier
@Primary

명시적(다른 개발자들이 코드를 보고 바로 알 수 있는것) vs 암묵적
ex) 명시적이지 않은경우, RDB 의존성 주입이 잘못되면 오류를 내지만 Nosql같은 경우는 에러가 안나와서 실제 1을 insert했는데 다른것을 insert할 수 있어서 위험하다.

## 42. @Transactional 격리레벨, 프로파게이션 알아보기

### propagation(전파)
* REQUIRED : 트랜잭션 필요. 진행 중이라면 해당 트랜잭션 사용. 없으면 생성
* MANDATORY : 트랜잭션 필요. 트랜잭션 존재하지 않으면 익셉션 발생
* NEVER : 트랜잭션이 불필요. 진행중인 트랜잭션 존재하면 익셉션 발생
* NESTED : 기존 트랜잭션 존재하면 중첩된 트랜잭션에서 메서드 실행

### isolation level(격리 레발)
* DEFAULT : 기본 설정
* READ_UNCOMMITED : 다른 트랜잭션에서 커밋하지 않는 데이터 읽기 가능
* READ_COMMITED : 다른 트랜잭션에 의해 커밋된 데이터 읽기 가능
* REPEATABLE_READ : 처음 읽은 데이터와 두 번째 읽은 데이터가 동일
* SERIALIZABLE : 동일한 데이터에 대해 두 개 이상의 트랜잭션 수행 불가

## 43. POJO가 왜 Spring에서 중요한지?

메소드 안에 보면 Spring에 의존적인 코드가 하나도 안들어있죠
결국엔 우리 코드안에는 비지니스만 남아있다는 말이다.
부가적인 스프링에 종속적인건 다빠져있죠 AOP 어노테이션으로
즉, 우리의 코드에는 비지니스만 남아있을 수 있어서 POJO가 중요하다
그렇다면 어노테이션은 Spring에 종속적인것이냐? 사실 부가기능이기때문에
다른 프레임워크를 사용해도 트랜잭션같은건 해당 프레임워크에 맞게 갈아끼우면 된다.
