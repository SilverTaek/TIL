## 1. GC에 대해 설명하시오
* 메모리를 안쓰고 있다라는것을 판단하는 기준은 객체가 더 이상 참조되지 않을 때 GC가 발생한다.
* A a = new A(); 가정하에 더 이상 a를 참조하는곳이 없으면 a는 Heap 영역으로 이동한다.
* Heap영역은 다시 Young Generation 영역과 Old Generation 영역으로 나뉘는데 Young 영역은 Eden 영역과 Survivor 0 / Survivor 1 영역으로 나뉜다. 
* Eden 영역에 쌓인 객체는 Survivor 0와 Survivor 1 영역에 번갈아가며 쌓이며 객체의 age가 증가하고 한계점에 다다르면 Old Generation으로 이동한다.
* Old Generation이 한계에 다다르면 Major GC가 발생한다.
* 객체의 크기가 큰 경우 Eden 영역에서 Survivor 영역으로 이동하지않고 바로 Old Generation영역으로 이동할 수 있다.

## 2. Static을 잘못쓰면 메로리릭이 발생할 수 있는데 어떨 때 발생할 수 있는가?(JAVA는 GC로 인해 메모리릭이 발생할 가능성이 낮은데 메모리릭이 발생할 수 있는 패턴에 대해 설명해보시오)

메모리릭은 개발자가 메모리 할당을 해놓고 할당을 해제안했을 때 발생하는 문제
static으로 자료구조를 선언하면 메모리가 제대로 할당해제가 안되고 찌꺼기가 쌓여 결국에는 메모리릭이 발생 할 수 있다.

## 3. 회원가입 할 때 HashMap을 static으로 만들고 public으로 선언했을 때 어떻게 될것인지?

다른 개발자가 유지보수의 관점에서 의도하지않게 회원가입을 하는 상황이 발생할 수 있다.
이러한 부분도 메모리릭이 발생할 수 있는 포인트이다.

## 4. 1KB는 몇 바이트일까?
1024 Byte

## 5. 캐싱에 대한 개념
쿼리를 실행할 때마다 비용이 증가하는데 반복되는 쿼리를 줄여 비용을 낮추기위해 메모리에 저장하여 응답속도를 개선하는 것
## 6. 메모리의 단점
용량이 적은데 가격이 비싸다.

결론적으로 서버 캐시 비용을 낮춰서 회사에 운영 비용을 낮춰 연봉 인상협상에 유리하게 작용할 수 있음

## 7. 톰캣 스레드풀, DB 커넥션풀 병목이 많이 일어나는데 자세히 알아보기
* Tomcat Thread pool : WAS의 종류중 하나인 Tomcat은 기본적으로 접근하는 request들에 대해 Thread를 할당하여 작업을 수행하도록 해준다.
Thread pool을 사용하여 쓰레드를 재사용 할 수 있게 해주고 max-thread, connection timeout 등의 설정을 사용자가 직접 설정 해 줄 수 있다.

```
Tomcat8 default 
maxThread = 200(쓰레드풀 최대 쓰레드 갯수)
minSpareThreads = 25(쓰레드풀 초기 쓰레드 갯수)
```

* DB Connection pool : DB Connection 정보를 캐시에 저장/관리하여 애플리케이션 단에서 DB Connection 정보가 필요할 때마다 Connection pool에서 연결 정보를 가지고 와 사용하도록 하는 것이다. connection pool에서 Connection 정보를 관리하기 때문에 DB에 연결하기 위한 연결 정보 생성 시간이 없어 DB Connection을 위한 시간이 월등히 줄어든다.

## 8. 쓰레드는 왜 사용해야 할까?(동시에 처리했을 때 빨라지는 이유)

## 9. I/O가 일어날 때 쓰레드가 어떻게 될까?
블로킹된다.

## 10. 스레드 개수를 늘리면 ContextSwitching이 늘어나는데 스레드 갯수를 줄이면서 처리량을 늘릴 수 있는 방법이 있는가?

## 11. NIO가 무엇인지?

## 12. WebFlux가 무엇인가?
스레드 갯수를 줄여서 NonBloking IO를 구현한것

## 13. Java8에서 새로나온것은?

## 14. Spring5에서 새로나온것은?

## 15. TCP UDP의 차이
손실되도 되는 데이터 -> UDP
카톡 -> TCP (성능이 느림) -> Point) 3-hand-shaking

## 16. Serialization이 뭘까요?

## 17. 어떨때 인터페이스를 써야하고 어떨때 추상클래스를 써야할까요?

## 18. Optional은 어떨때 왜쓰는걸까요?

## 19. Push 메세지를 날리는 서버를 만들 때 성능을 높일 수 있는 방법은 어떤게 있을까요?
push 메세지를 최대한 많이 보내야하는데 밑도 끝도없이 막 던질 수 있는 방법은 무엇이 있는지 
던졌을 때 요청을 보냈을 때 응답이 올때까지 기다리는 부분을 해결하기 위해서 NonBlokingI/O를 사용해야 합니다. 따라서 짧은 시간안에 확 던질 수 있다.

NonBlokingI/O도 요청이 많이 발생했을 때 메모리에 저장해야하는데 이럴 때 OutOfMemory가 발생할 수 있다.

이를 해결하기위해 WebSocket을 사용한다. 단방향 즉, 응답을 받을 필요가 없다. TCP 특징을 이용해서 상대방에게 잘전송이됐는지만 중요하다.

## 20. Session은 어디에 저장이 될지?
메모리에 저장
Session은 임시성 데이터, 클라이언트가 최초로 접속했을 때 세션이 생성된다.
SessionId를 통해 사용자를 식별하고 Id가 없으면 최초 접속했다고 판단한다. 또한 쿠키에 담아서 온다.
Header에 담아서 오는데 set cookie header이다.

## 21. CPU 사용량이 높아졌을 때 어떻게 해야할지?
ScaleOut , ScaleUp 각각의 특징 살펴보기.

## 22. Auth 살펴보기

## 23. Filter라는것은 개발할 때 어떻게 사용할 수 있을지?

## 24. 인터셉터와 필터의 차이 (실행되는 시점 제외)

## 25. 커넥션을 만드는게 왜느릴지?

JDBC를 개발할 때 커넥션을 열고 닫고하는 반복적인 부분이 발생하는데 TCP에서 커넥션을 맺을 때 3-hand-shaking, 닫을 때는 4-hand-shaking이 반복적으로 발생하기 때문에 TCP는 맺고 끝는게 매우 느려서 풀을 만들어서 돌려서 사용한다.

## 26. MVC?

## 27. DispatcherServlet?

## 28. 배민 시험 과제(서블릿 구조 만들어오기, DispatcherServlet부터 껍데기부터 톰캣자체를 혼자서 만들어 오기 그래서 웹으로 접속했을 때 눈에 보여야하고 Http가 출력)

## 29. 서버에서 SessionId를 생성했을 때 클라이언트의 쿠키에 자동으로 세팅되는데 어떤거 때문에 ?
서버에서 세션을 만들어주고 응답의 헤더에 SetCookie를 만들어준다.

## 30. 서버가 Stateless하다라는것은 무슨 말일까?
서버에 어떤 값을 저장하지 않는것 -> 장점은 어떤게 있을까?
동일한 값을 공유하기위해 부하가 생긴다. -> 서버에 값을 저장하지않으면 이러한 부담을 줄어들어서 서버의 성능이 빨라진다.

## 31. sticky Session, Session Clustering

## 32. 캐싱관련 LRU, LFU

## 33. 디자인 패턴의 정의
oop를 잘지키기위한 패턴, solid 5원칙같이 개발자들이 잘지키려고한 패턴들을 모아서 만든게 디자인 패턴

## 34. 단일책임원칙을 적용했을 때 프로젝트에 어떻게 좋아질지?
재사용성이 높아짐

## 35. 개방폐쇄원칙과 다형성의 연관성은?
인터페이스 -> 변경에 닫혀있음, 확장에 열려있음
